<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Scala.md</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://stackedit.io/libs/MathJax/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><p><style>svg.railroad-diagram path { stroke-width: 3; stroke: black; fill: rgba(0,0,0,0); } svg.railroad-diagram text {   font: bold 14px monospace; text-anchor: middle; } svg.railroad-diagram text.label { text-anchor: start; } svg.railroad-diagram text.comment { font: italic 12px monospace; } svg.railroad-diagram rect { stroke-width: 3; stroke: black; fill: hsl(120,100%,90%); }</style></p>

<h1 id="scala">Scala</h1>

<p><div class="toc">
<ul>
<li><a href="#scala">Scala</a><ul>
<li><a href="#mathematical-functions">Mathematical functions</a><ul>
<li><a href="#discontinuous-functions">Discontinuous functions</a></li>
<li><a href="#partial-functions">Partial functions</a></li>
</ul>
</li>
<li><a href="#scala-code-for-functions">Scala code for functions</a><ul>
<li><a href="#a-quick-detour">A quick detour</a></li>
<li><a href="#function-definition-revisited">Function definition, revisited</a></li>
<li><a href="#procedures-and-expressions">Procedures, and expressions</a><ul>
<li><a href="#the-substitution-principle">The substitution principle</a></li>
<li><a href="#the-if-conditional">The “if” conditional</a></li>
</ul>
</li>
<li><a href="#recursive-functions">Recursive functions</a></li>
<li><a href="#tail-recursive-function">Tail recursive function</a></li>
<li><a href="#procedures">Procedures</a></li>
<li><a href="#blocks-of-code">Blocks of code</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#types">Types</a><ul>
<li><a href="#type-hierarchy">Type Hierarchy</a><ul>
<li><a href="#primitive-types">Primitive types</a></li>
<li><a href="#implicit-conversions">Implicit conversions</a></li>
<li><a href="#type-inflection">Type inflection</a></li>
<li><a href="#functions-as-types">Functions as types</a></li>
</ul>
</li>
<li><a href="#structures-and-classes">Structures and classes</a><ul>
<li><a href="#methods-and-attributes">Methods and attributes</a><ul>
<li><a href="#functional-way-of-calling-methods">Functional way of calling methods</a></li>
</ul>
</li>
<li><a href="#constructors">Constructors</a></li>
<li><a href="#inheritance">Inheritance</a></li>
<li><a href="#abstract-classes-and-contracts">Abstract classes and contracts</a><ul>
<li><a href="#the-shopping-cart">The shopping cart</a></li>
<li><a href="#representing-an-empty-shopping-cart">Representing an empty shopping cart</a></li>
<li><a href="#a-single-product-cart">A single product cart</a></li>
<li><a href="#a-cart-for-more-products">A cart for more products</a><ul>
<li><a href="#understading-and-proving">Understading, and proving</a></li>
</ul>
</li>
<li><a href="#removing-unused-code">Removing unused code.</a></li>
</ul>
</li>
<li><a href="#anonymous-classes">Anonymous classes</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</p>

<p>Before we talk about Scala, let’s talk about functions. First of all, we need to understand what functions are, and what they mean in the context of programming.</p>

<p>First of all, functions came from the mathematics, so we’ll look at these functions first. </p>

<h2 id="mathematical-functions">Mathematical functions</h2>

<p>When we’re solving some equation on math, we will use functions. A function is, simply, some name that maps a number of “identifiers” into a result. For instance, let’s take a function that simply sums any number by two:</p>

<p><code>f(x) = x + 2</code></p>

<p>In this example, we have a function named <code>f</code>. This function maps an <em>identifier</em>, in this case, <code>x</code>, to a function. That function simply sums the <em>identifier</em> with <code>2</code>. So:</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">f</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> x </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln">
f</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln">
f</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">6</span></code></pre>

<p>The first line is what we call <strong>function definition</strong>, because it <strong>defines</strong> a function (in this case, <code>f</code>). The second line is what we call the <strong>function application</strong>, because it <strong>applies</strong> a parameter (in this case, the <code>4</code>) into the function. When we <strong>apply</strong> a function, we get a result. It is as simple as that.</p>

<h3 id="discontinuous-functions">Discontinuous functions</h3>

<p>In math, we can have functions which are <em>discontinuous</em>. Such functions have the following format:</p>

<p><span class="MathJax_Preview"></span><div class="MathJax_Display" role="textbox" aria-readonly="true" style="text-align: center;"><span class="MathJax" id="MathJax-Element-3-Frame"><nobr><span class="math" id="MathJax-Span-78" style="width: 11.141em; display: inline-block;"><span style="display: inline-block; position: relative; width: 9.446em; height: 0px; font-size: 118%;"><span style="position: absolute; clip: rect(2.424em 1000.003em 5.209em -0.663em); top: -4.053em; left: 0.003em;"><span class="mrow" id="MathJax-Span-79"><span class="mi" id="MathJax-Span-80" style="font-family: STIXGeneral; font-style: italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.124em;"></span></span><span class="mo" id="MathJax-Span-81" style="font-family: STIXGeneral;">(</span><span class="mi" id="MathJax-Span-82" style="font-family: STIXGeneral; font-style: italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-83" style="font-family: STIXGeneral;">)</span><span class="mo" id="MathJax-Span-84" style="font-family: STIXGeneral; padding-left: 0.306em;">=</span><span class="mrow" id="MathJax-Span-85" style="padding-left: 0.306em;"><span class="mo" id="MathJax-Span-86" style="vertical-align: -0.602em;"><span style="font-family: STIXSizeThreeSym;">{</span></span><span class="mtable" id="MathJax-Span-87" style="padding-right: 0.185em; padding-left: 0.185em;"><span style="display: inline-block; position: relative; width: 5.512em; height: 0px;"><span style="position: absolute; clip: rect(2.364em 1000.003em 4.906em -0.421em); top: -3.992em; left: 0.003em;"><span style="display: inline-block; position: relative; width: 0.729em; height: 0px;"><span style="position: absolute; clip: rect(2.909em 1000.003em 4.543em -0.421em); top: -4.537em; left: 0.003em;"><span class="mtd" id="MathJax-Span-88"><span class="mrow" id="MathJax-Span-89"><span class="mfrac" id="MathJax-Span-90" style="padding-left: 0.124em; padding-right: 0.124em;"><span style="display: inline-block; position: relative; width: 0.487em; height: 0px;"><span style="position: absolute; clip: rect(1.516em 1000.003em 2.364em -0.481em); top: -2.6em; left: 50%; margin-left: -0.179em;"><span class="mn" id="MathJax-Span-91" style="font-size: 70.7%; font-family: STIXGeneral;">1</span><span style="display: inline-block; width: 0px; height: 2.182em;"></span></span><span style="position: absolute; clip: rect(1.698em 1000.003em 2.364em -0.542em); top: -1.813em; left: 50%; margin-left: -0.179em;"><span class="mi" id="MathJax-Span-92" style="font-size: 70.7%; font-family: STIXGeneral; font-style: italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span style="display: inline-block; width: 0px; height: 2.182em;"></span></span><span style="position: absolute; clip: rect(0.85em 1000.003em 1.274em -0.542em); top: -1.329em; left: 0.003em;"><span style="border-left-width: 0.487em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 1.25px; vertical-align: 0.003em;"></span><span style="display: inline-block; width: 0px; height: 1.093em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(1.698em 1000.003em 2.727em -0.421em); top: -1.813em; left: 0.003em;"><span class="mtd" id="MathJax-Span-98"><span class="mrow" id="MathJax-Span-99"><span class="mn" id="MathJax-Span-100" style="font-family: STIXGeneral;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.606em 1000.003em 4.906em -0.542em); top: -3.992em; left: 1.88em;"><span style="display: inline-block; position: relative; width: 3.635em; height: 0px;"><span style="position: absolute; clip: rect(1.698em 1000.003em 2.909em -0.542em); top: -3.084em; left: 0.003em;"><span class="mtd" id="MathJax-Span-93"><span class="mrow" id="MathJax-Span-94"><span class="mtext" id="MathJax-Span-95" style="font-family: STIXGeneral;">for x</span><span class="mo" id="MathJax-Span-96" style="font-family: STIXGeneral; padding-left: 0.306em;">≠</span><span class="mn" id="MathJax-Span-97" style="font-family: STIXGeneral; padding-left: 0.306em;">0</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span><span style="position: absolute; clip: rect(1.698em 1000.003em 2.727em -0.542em); top: -1.813em; left: 0.003em;"><span class="mtd" id="MathJax-Span-101"><span class="mrow" id="MathJax-Span-102"><span class="mtext" id="MathJax-Span-103" style="font-family: STIXGeneral;">for x</span><span class="mo" id="MathJax-Span-104" style="font-family: STIXGeneral; padding-left: 0.306em;">=</span><span class="mn" id="MathJax-Span-105" style="font-family: STIXGeneral; padding-left: 0.306em;">0</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.059em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 3.075em; vertical-align: -1.211em;"></span></span></nobr></span></div><script type="math/tex; mode=display" id="MathJax-Element-3">
\begin{equation}
    f(x) = \begin{cases}
        \frac{1}{x} & \text{for x} \neq 0 \\
        1 & \text{for x} = 0
    \end{cases}
\end{equation}
</script></p>

<p>This function is called <em>discontinuous</em> because of the <em>condition</em>: if the variable <code>x</code> is different from zero, then the function is <code>1</code> divided by <code>x</code>. If it is equals to zero, then the function result is zero. In most programming languages, we have the <code>if</code> command that will serve the purpose to decide which path we should take, if a condition is true. But, before that, let’s see how would we translate this condition above to most of programming languages we have today:</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">f</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> x </span><span class="kwd">if</span><span class="pln"> x </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
f</span><span class="pun">(</span><span class="pln">x</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> x </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span></code></pre>

<p>Notice that the <strong>equals</strong> sign is written as <code>==</code>. The <strong>different</strong> sign, is written as <code>!=</code>. And, the <strong>division</strong> is written as <code>/</code>. If we had a multiplication, we would write as <code>*</code>. But this code, above, is still not a Scala code - but, before we present the scala code for that, we should look into another kind of function:</p>

<h3 id="partial-functions">Partial functions</h3>

<p>In math, a <em>partial function</em> is one that is defined only for a specific subset. Let’s see, for instance, this kind of function: </p>

<p><span class="MathJax_Preview"></span><div class="MathJax_Display" role="textbox" aria-readonly="true" style="text-align: center;"><span class="MathJax" id="MathJax-Element-4-Frame"><nobr><span class="math" id="MathJax-Span-106" style="width: 23.005em; display: inline-block;"><span style="display: inline-block; position: relative; width: 19.495em; height: 0px; font-size: 118%;"><span style="position: absolute; clip: rect(2.424em 1000.003em 5.209em -0.663em); top: -4.053em; left: 0.003em;"><span class="mrow" id="MathJax-Span-107"><span class="mi" id="MathJax-Span-108" style="font-family: STIXGeneral; font-style: italic;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.124em;"></span></span><span class="mi" id="MathJax-Span-109" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-110" style="font-family: STIXGeneral; font-style: italic;">c</span><span class="mi" id="MathJax-Span-111" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-112" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-113" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-114" style="font-family: STIXGeneral; font-style: italic;">i</span><span class="mi" id="MathJax-Span-115" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-116" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-117" style="font-family: STIXGeneral;">(</span><span class="mi" id="MathJax-Span-118" style="font-family: STIXGeneral; font-style: italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-119" style="font-family: STIXGeneral;">)</span><span class="mo" id="MathJax-Span-120" style="font-family: STIXGeneral; padding-left: 0.306em;">=</span><span class="mrow" id="MathJax-Span-121" style="padding-left: 0.306em;"><span class="mo" id="MathJax-Span-122" style="vertical-align: -0.602em;"><span style="font-family: STIXSizeThreeSym;">{</span></span><span class="mtable" id="MathJax-Span-123" style="padding-right: 0.185em; padding-left: 0.185em;"><span style="display: inline-block; position: relative; width: 12.412em; height: 0px;"><span style="position: absolute; clip: rect(2.606em 1000.003em 4.846em -0.542em); top: -3.992em; left: 0.003em;"><span style="display: inline-block; position: relative; width: 7.63em; height: 0px;"><span style="position: absolute; clip: rect(1.698em 1000.003em 2.909em -0.542em); top: -3.084em; left: 0.003em;"><span class="mtd" id="MathJax-Span-124"><span class="mrow" id="MathJax-Span-125"><span class="mi" id="MathJax-Span-126" style="font-family: STIXGeneral; font-style: italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-127" style="font-family: STIXGeneral; padding-left: 0.245em;">∗</span><span class="mi" id="MathJax-Span-128" style="font-family: STIXGeneral; font-style: italic; padding-left: 0.245em;">f<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.124em;"></span></span><span class="mi" id="MathJax-Span-129" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-130" style="font-family: STIXGeneral; font-style: italic;">c</span><span class="mi" id="MathJax-Span-131" style="font-family: STIXGeneral; font-style: italic;">t<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-132" style="font-family: STIXGeneral; font-style: italic;">o</span><span class="mi" id="MathJax-Span-133" style="font-family: STIXGeneral; font-style: italic;">r<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mi" id="MathJax-Span-134" style="font-family: STIXGeneral; font-style: italic;">i</span><span class="mi" id="MathJax-Span-135" style="font-family: STIXGeneral; font-style: italic;">a</span><span class="mi" id="MathJax-Span-136" style="font-family: STIXGeneral; font-style: italic;">l<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-137" style="font-family: STIXGeneral;">(</span><span class="mi" id="MathJax-Span-138" style="font-family: STIXGeneral; font-style: italic;">x<span style="display: inline-block; overflow: hidden; height: 1px; width: 0.003em;"></span></span><span class="mo" id="MathJax-Span-139" style="font-family: STIXGeneral; padding-left: 0.245em;">−</span><span class="mn" id="MathJax-Span-140" style="font-family: STIXGeneral; padding-left: 0.245em;">1</span><span class="mo" id="MathJax-Span-141" style="font-family: STIXGeneral;">)</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span><span style="position: absolute; clip: rect(1.698em 1000.003em 2.727em -0.421em); top: -1.873em; left: 0.003em;"><span class="mtd" id="MathJax-Span-147"><span class="mrow" id="MathJax-Span-148"><span class="mn" id="MathJax-Span-149" style="font-family: STIXGeneral;">1</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span><span style="position: absolute; clip: rect(2.606em 1000.003em 4.846em -0.542em); top: -3.992em; left: 8.78em;"><span style="display: inline-block; position: relative; width: 3.635em; height: 0px;"><span style="position: absolute; clip: rect(1.698em 1000.003em 2.727em -0.542em); top: -3.084em; left: 0.003em;"><span class="mtd" id="MathJax-Span-142"><span class="mrow" id="MathJax-Span-143"><span class="mtext" id="MathJax-Span-144" style="font-family: STIXGeneral;">for x</span><span class="mo" id="MathJax-Span-145" style="font-family: STIXGeneral; padding-left: 0.306em;">&gt;</span><span class="mn" id="MathJax-Span-146" style="font-family: STIXGeneral; padding-left: 0.306em;">0</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span><span style="position: absolute; clip: rect(1.698em 1000.003em 2.727em -0.542em); top: -1.873em; left: 0.003em;"><span class="mtd" id="MathJax-Span-150"><span class="mrow" id="MathJax-Span-151"><span class="mtext" id="MathJax-Span-152" style="font-family: STIXGeneral;">for x</span><span class="mo" id="MathJax-Span-153" style="font-family: STIXGeneral; padding-left: 0.306em;">=</span><span class="mn" id="MathJax-Span-154" style="font-family: STIXGeneral; padding-left: 0.306em;">0</span></span></span><span style="display: inline-block; width: 0px; height: 2.545em;"></span></span></span><span style="display: inline-block; width: 0px; height: 3.998em;"></span></span></span></span></span></span><span style="display: inline-block; width: 0px; height: 4.059em;"></span></span></span><span style="border-left-width: 0.004em; border-left-style: solid; display: inline-block; overflow: hidden; width: 0px; height: 3.075em; vertical-align: -1.211em;"></span></span></nobr></span></div><script type="math/tex; mode=display" id="MathJax-Element-4">
\begin{equation}
    factorial(x) = \begin{cases}
        x * factorial(x - 1) & \text{for x} \gt 0 \\
        1 & \text{for x} = 0
    \end{cases}
\end{equation}
</script></p>

<p>So, what’s the result for <code>x</code> that is below zero? The answer is, is <strong>undefined</strong> - we have no result. This kind of function is called a <em>partial function</em> because it is defined only for a subset of “x”. In this sense, <strong>all functions</strong> in programming languages are partial functions - because they are only defined for a specific subset of objects - but we should get into this later. For now, let’s see how is the Scala code for that:</p>

<h2 id="scala-code-for-functions">Scala code for functions</h2>

<p>Let’s pick our first example: the one where we defined a function that sums a number with <code>2</code>. To be able to define this function, we need to specify for <strong>which kind of parameters</strong> our function will work: will it work with integers only? Or, will it accept decimals too? This kind of information we call the <em>type</em> of the parameter. For now, let’s say our function will only work for integers: in Scala, the type for integers is <code>Int</code>, and we’ll define that some identifier is of type <code>Int</code> by suffixing it with <code>: Int</code>. So, let’s say we want to say that <code>x</code> is of type <code>Int</code>: we’ll use the syntax <code>x: Int</code>.</p>

<p>We define functions using the keyword <code>def</code>. So, to define our function, we say:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> sumByTwo</span><span class="pun">(</span><span class="pln">x</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> x </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span></code></pre>

<h3 id="a-quick-detour">A quick detour</h3>

<p>To be able to understand more of our Scala code, we’ll use a simple kind of diagram called <strong>railroad diagram</strong>. Like a real railroad, you <strong>must</strong> follow the lines, and you can’t go back. Like a real railroad, any path you follow will lead you to a working code. Let’s see a simple example: suppose you want to say “Hello” to a bunch of people, in English. And it’s morning. These are the ways you can say it:</p>

<p><svg class="railroad-diagram" width="657" height="142" viewBox="0 0 657 142"><g transform="translate(.5 .5)"><path d="M 20 31 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path><g><path d="M40 41h0"></path><path d="M248 41h0"></path><path d="M40 41h20"></path><g><path d="M60 41h0"></path><path d="M228 41h0"></path><path d="M60 41h10"></path><g><path d="M70 41h0"></path><path d="M122 41h0"></path><rect x="70" y="30" width="52" height="22" rx="10" ry="10"></rect><text x="96" y="45">Good</text></g><path d="M122 41h10"></path><path d="M132 41h10"></path><g><path d="M142 41h0"></path><path d="M218 41h0"></path><rect x="142" y="30" width="76" height="22" rx="10" ry="10"></rect><text x="180" y="45">Morning</text></g><path d="M218 41h10"></path></g><path d="M228 41h20"></path><path d="M40 41a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path><g><path d="M60 71h54"></path><path d="M174 71h54"></path><rect x="114" y="60" width="60" height="22" rx="10" ry="10"></rect><text x="144" y="75">Hello</text></g><path d="M228 71a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path></g><g><path d="M248 41h0"></path><path d="M616 41h0"></path><path d="M248 41a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path><g><path d="M268 21h328"></path></g><path d="M596 21a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><path d="M248 41h20"></path><g><path d="M268 41h96"></path><path d="M500 41h96"></path><path d="M364 41h10"></path><g><path d="M374 41h0"></path><path d="M402 41h0"></path><rect x="374" y="30" width="28" height="22" rx="10" ry="10"></rect><text x="388" y="45">,</text></g><path d="M402 41h10"></path><path d="M412 41h10"></path><g><path d="M422 41h0"></path><path d="M490 41h0"></path><rect x="422" y="30" width="68" height="22"></rect><text x="456" y="45">&lt;name&gt;</text></g><path d="M490 41h10"></path></g><path d="M596 41h20"></path><path d="M248 41a10 10 0 0 1 10 10v20a10 10 0 0 0 10 10"></path><g><path d="M268 81h0"></path><path d="M596 81h0"></path><path d="M268 81h10"></path><g><path d="M278 81h0"></path><path d="M306 81h0"></path><rect x="278" y="70" width="28" height="22" rx="10" ry="10"></rect><text x="292" y="85">,</text></g><path d="M306 81h10"></path><g><path d="M316 81h0"></path><path d="M444 81h0"></path><path d="M316 81a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path><g><path d="M336 61h88"></path></g><path d="M424 61a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><path d="M316 81h20"></path><g><path d="M336 81h0"></path><path d="M424 81h0"></path><path d="M336 81h10"></path><g><path d="M346 81h0"></path><path d="M414 81h0"></path><rect x="346" y="70" width="68" height="22"></rect><text x="380" y="85">&lt;name&gt;</text></g><path d="M414 81h10"></path><path d="M346 81a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path><g><path d="M346 111h20"></path><path d="M394 111h20"></path><rect x="366" y="100" width="28" height="22" rx="10" ry="10"></rect><text x="380" y="115">,</text></g><path d="M414 111a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path></g><path d="M424 81h20"></path></g><path d="M444 81h10"></path><g><path d="M454 81h0"></path><path d="M498 81h0"></path><rect x="454" y="70" width="44" height="22" rx="10" ry="10"></rect><text x="476" y="85">and</text></g><path d="M498 81h10"></path><path d="M508 81h10"></path><g><path d="M518 81h0"></path><path d="M586 81h0"></path><rect x="518" y="70" width="68" height="22"></rect><text x="552" y="85">&lt;name&gt;</text></g><path d="M586 81h10"></path></g><path d="M596 81a10 10 0 0 0 10 -10v-20a10 10 0 0 1 10 -10"></path></g><path d="M 616 41 h 20 m -10 -10 v 20 m 10 -20 v 20"></path></g></svg></p>

<p>If we follow the railroad, we’ll see that there are only a bunch of ways to say Hello: we follow the “Good” and “Morning” path, or we follow the “Hello” path: So, first of all, we got <code>Good Morning</code> or <code>Hello</code> as possible ways to say it - please notice that rounded squares means that we need to write <strong>exactly</strong> as is written - not even lower and upper case can be changed. </p>

<p>Following, we can simply go to the end, or we can use a comma (<code>,</code>) followed by a <code>&lt;name&gt;</code> - here, we have a square. Squares means that what we’ll say is variable - we just need to follow a bunch of rules, that we’ll detail later. In this case, <strong>name</strong> is just what it says - a person’s name. Let’s use “Alice” in this example. If we follow this path, we end with: <code>Good Morning, Alice</code> or <code>Hello, Alice</code>. Then, we end.</p>

<p>There’s another way, that it’s the third path - we can have multiple (more than one) names, following the rule: we put a comma, a name, and we can put another comma and another name (here, the process repeats), and we end it with <code>and</code> and another name. So, in this case, <code>Alice and Bob</code>, <code>Alice, Bob and Eve</code>, even <code>Alice, Bob, Richard, Eve, Santa and Silva</code> are valid paths. And then, we end - so, possible ways to say “Hello”, following this path, are <code>Hello, Alice and Bob</code>, <code>Good Morning, Alice, Bob and Eve</code>, and so forth.</p>

<h3 id="function-definition-revisited">Function definition, revisited</h3>

<p>The full syntax of defining functions, in Scala, is the following railroad diagram:</p>

<p><svg class="railroad-diagram" width="1293" height="321" viewBox="0 0 1293 321"><g transform="translate(.5 .5)"><path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path><path d="M40 31h10"></path><g><path d="M50 31h0"></path><path d="M94 31h0"></path><rect x="50" y="20" width="44" height="22" rx="10" ry="10"></rect><text x="72" y="35">def</text></g><path d="M94 31h10"></path><path d="M104 31h10"></path><g><path d="M114 31h0"></path><path d="M206 31h0"></path><rect x="114" y="20" width="92" height="22"></rect><text x="160" y="35">&lt;fn-name&gt;</text></g><path d="M206 31h10"></path><g><path d="M216 31h0"></path><path d="M724 31h0"></path><path d="M216 31h20"></path><g><path d="M236 31h468"></path></g><path d="M704 31h20"></path><path d="M216 31a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><g><path d="M236 51h0"></path><path d="M704 51h0"></path><path d="M236 51h10"></path><g><path d="M246 51h0"></path><path d="M274 51h0"></path><rect x="246" y="40" width="28" height="22" rx="10" ry="10"></rect><text x="260" y="55">(</text></g><path d="M274 51h10"></path><g><path d="M284 51h0"></path><path d="M656 51h0"></path><path d="M284 51h20"></path><g><path d="M304 51h332"></path></g><path d="M636 51h20"></path><path d="M284 51a10 10 0 0 1 10 10v9a10 10 0 0 0 10 10"></path><g><path d="M304 80h0"></path><path d="M636 80h0"></path><path d="M304 80a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path><g><path d="M324 60h292"></path></g><path d="M616 60a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><path d="M304 80h20"></path><g><path d="M324 80h0"></path><path d="M616 80h0"></path><path d="M324 80h10"></path><g><path d="M334 80h0"></path><path d="M606 80h0"></path><path d="M334 80h10"></path><g><path d="M344 80h0"></path><path d="M460 80h0"></path><rect x="344" y="69" width="116" height="22"></rect><text x="402" y="84">&lt;param-name&gt;</text></g><path d="M460 80h10"></path><path d="M470 80h10"></path><g><path d="M480 80h0"></path><path d="M508 80h0"></path><rect x="480" y="69" width="28" height="22" rx="10" ry="10"></rect><text x="494" y="84">:</text></g><path d="M508 80h10"></path><path d="M518 80h10"></path><g><path d="M528 80h0"></path><path d="M596 80h0"></path><rect x="528" y="69" width="68" height="22"></rect><text x="562" y="84">&lt;type&gt;</text></g><path d="M596 80h10"></path></g><path d="M606 80h10"></path><path d="M334 80a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path><g><path d="M334 110h122"></path><path d="M484 110h122"></path><rect x="456" y="99" width="28" height="22" rx="10" ry="10"></rect><text x="470" y="114">,</text></g><path d="M606 110a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path></g><path d="M616 80h20"></path></g><path d="M636 80a10 10 0 0 0 10 -10v-9a10 10 0 0 1 10 -10"></path></g><path d="M656 51h10"></path><g><path d="M666 51h0"></path><path d="M694 51h0"></path><rect x="666" y="40" width="28" height="22" rx="10" ry="10"></rect><text x="680" y="55">)</text></g><path d="M694 51h10"></path></g><path d="M704 51a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path></g><g><path d="M724 31h20a10 10 0 0 1 10 10v90a10 10 0 0 1 -10 10h-724a10 10 0 0 0 -10 10v31a10 10 0 0 0 10 10"></path></g><g><path d="M20 192h0"></path><path d="M252 192h0"></path><path d="M20 192h20"></path><g><path d="M40 192h192"></path></g><path d="M232 192h20"></path><path d="M20 192a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><g><path d="M40 212h0"></path><path d="M232 212h0"></path><path d="M40 212h10"></path><g><path d="M50 212h0"></path><path d="M78 212h0"></path><rect x="50" y="201" width="28" height="22" rx="10" ry="10"></rect><text x="64" y="216">:</text></g><path d="M78 212h10"></path><path d="M88 212h10"></path><g><path d="M98 212h0"></path><path d="M222 212h0"></path><rect x="98" y="201" width="124" height="22"></rect><text x="160" y="216">&lt;return-type&gt;</text></g><path d="M222 212h10"></path></g><path d="M232 212a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path></g><g><path d="M252 192h0"></path><path d="M548 192h0"></path><path d="M252 192h20"></path><g><path d="M272 192h0"></path><path d="M528 192h0"></path><path d="M272 192h10"></path><g><path d="M282 192h0"></path><path d="M310 192h0"></path><rect x="282" y="181" width="28" height="22" rx="10" ry="10"></rect><text x="296" y="196">{</text></g><path d="M310 192h10"></path><path d="M320 192h10"></path><g><path d="M330 192h0"></path><path d="M470 192h0"></path><rect x="330" y="181" width="140" height="22"></rect><text x="400" y="196">&lt;function-body&gt;</text></g><path d="M470 192h10"></path><path d="M480 192h10"></path><g><path d="M490 192h0"></path><path d="M518 192h0"></path><rect x="490" y="181" width="28" height="22" rx="10" ry="10"></rect><text x="504" y="196">}</text></g><path d="M518 192h10"></path></g><path d="M528 192h20"></path><path d="M252 192a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path><g><path d="M272 222h34"></path><path d="M494 222h34"></path><rect x="306" y="211" width="188" height="22"></rect><text x="400" y="226">&lt;function-expression&gt;</text></g><path d="M528 222a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path></g><path d="M 548 192 h 20 m -10 -10 v 20 m 10 -20 v 20"></path></g></svg></p>

<ul>
<li><strong>fn-name</strong> is a function name. This defines the name of the function, and <strong>must</strong> be written with camelCase<a href="#fn:camelcase" id="fnref:camelcase" title="See footnote" class="footnote">1</a> notation</li>
<li><strong>param-name</strong> is a parameter name. This defines the name of a parameter in a function, in camelCase notation. It can not have the same name as another parameter in this same function</li>
<li><strong>type</strong> the type of parameter, like <code>Int</code> or <code>Double</code> or <code>String</code>. We’ll see more types later, so for now, <code>Int</code> is an Integer, and <code>Double</code> is a Decimal.</li>
<li><strong>return-type</strong>: the function, too, must return a type, so we declare it explicit here. We can omit this parameter, but sometimes the function will not be able to infer the return type, so we need to declare it explicit in these cases</li>
<li><strong>function-body</strong> is a list of commands, statements, and such things that will be run when this function is called (applyied). We’ll see “blocks of code” later</li>
<li><strong>function-expression</strong> is a single expression that will be evaluated, and the return of this expression will be the return of the function. One of these possible expressions is <code>0</code> (in this case, it’ll just return <strong>0</strong>), and other, more complicated ways to do this, is to use the <code>if</code> statement to evaluate a condition.</li>
</ul>

<p>So, for instance, we could write the following functions (and all of then would be valid definitions):</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">+</span><span class="pln"> param2

</span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">*</span><span class="pln"> param2

</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">number</span><span class="pun">,</span><span class="pln"> number</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln">
  sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">param2</span><span class="pun">))</span></code></pre>

<p>Below, there are some lines of code that work, and some that don’t. Can you guess why? The answer is in a footnote<a href="#fn:answer1" id="fnref:answer1" title="See footnote" class="footnote">2</a>, but I <strong>strongly</strong> encourage you to understand why</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// This is a comment: it will not be interpreted by Scala in any way</span><span class="pln">
</span><span class="com">// This code below will not work. Can you guess why?</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> multiplyByTwo</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">number</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln">

</span><span class="com">// But this code will work. Can you guess why?</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumByTwo</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">number</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span></code></pre>

<h3 id="procedures-and-expressions">Procedures, and expressions</h3>

<p>For now, we saw a lot of code using “functions”. But, so far, our program is simply a calculator - it doesn’t <strong>do</strong> anything that any simple calculator can do. So, for now, let’s talk about procedures.</p>

<p>We can understand functions, in programming languages, as something that gets a bunch of parameters, and returns an operation on these parameters (like sum, multiply, etc). We can imagine these “function” as verbs, like:</p>

<pre class="prettyprint prettyprinted"><code><span class="pln">TO sum squares of two numbers n1 </span><span class="kwd">and</span><span class="pln"> n2
  we SUM
    the square of n1
    </span><span class="kwd">with</span><span class="pln"> the square of n2</span></code></pre>

<p>Looking at the above description, it is easy to see that our implementation, above, was correct:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">+</span><span class="pln"> param2

</span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">*</span><span class="pln"> param2

</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">number</span><span class="pun">,</span><span class="pln"> number</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln">
  sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span></code></pre>

<p>Procedures are like functions, but they don’t <strong>return</strong> anything. We’ll see procedures later, but as for now, we can imagine a code that prints something into the screen as a procedure - it just prints something, it does not return anything and it is not expected to do it anyway. In Scala, there’s a special type for procedures - <code>Unit</code>. So, in Scala, we can say that a procedure is a function that <strong>returns</strong> <code>Unit</code>, and that <code>Unit</code> is a special type that has no meaning, cannot be converted to and from anything, and <strong>must</strong> be discarded. </p>

<p>As for functions, we’re still missing one point: we need to know what is happening in the code. Suppose that I have the following application<a href="#fn:application" id="fnref:application" title="See footnote" class="footnote">3</a> of the above function:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span></code></pre>

<p>How will the computer computes the result of this function? Will it return an integer? What we’re expecting is the result <code>25</code>, but it is correct?</p>

<h4 id="the-substitution-principle">The substitution principle</h4>

<p>A simple way to check if this result is correct is to <em>substitute</em> all the parameters in the function, so we check if everything is working. Let’s do it to the <code>sumOfSquares(3, 4)</code> and see if we get <code>25</code> in the end:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// Just to remember, these are the definitions:</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">+</span><span class="pln"> param2
</span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">param1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> param2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> param1 </span><span class="pun">*</span><span class="pln"> param2
</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">number</span><span class="pun">,</span><span class="pln"> number</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span><span class="pln">

</span><span class="com">// And this is the call:</span><span class="pln">
sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln">

</span><span class="com">// First, we substitute the parameters in the order they appear:</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="lit">3</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="lit">3</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="lit">4</span><span class="pun">))</span><span class="pln">

</span><span class="com">// Nothing to do, we expand now the parameters inside the "sum" function:</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> multiply</span><span class="pun">(</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln">
</span><span class="com">// So..</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">multiply</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">),</span><span class="pln"> multiply</span><span class="pun">(</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">))</span><span class="pln">

</span><span class="com">// We have expanded "square", but even after the expansion, there's still</span><span class="pln">
</span><span class="com">// parameters inside the "sum". Let's expand these too:</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">3</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="lit">4</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">4</span><span class="pln">
</span><span class="com">// So...</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln">
</span><span class="com">// So...</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="lit">9</span><span class="pun">,</span><span class="pln"> </span><span class="lit">16</span><span class="pun">)</span><span class="pln">

</span><span class="com">// Now, we expand the "sum" itself. Remember, "sum" takes a Double...</span><span class="pln">
sum</span><span class="pun">(</span><span class="lit">9</span><span class="pun">,</span><span class="pln"> </span><span class="lit">16</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">9.0</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">16.0</span><span class="pln">
</span><span class="com">// So...</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">9.0</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">16.0</span><span class="pln">
</span><span class="com">// So...</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">25.0</span></code></pre>

<p>On the above substitution, we discovered an interesting thing: our <code>sumOfSquares</code> function is a function that maps two parameters of type <code>Int</code> to a single parameter of time <code>Double</code>. Scala correctly inferred the type for us, but maybe it wasn’t what we wanted. So far, we need to be aware of these behaviors when writing our programs.</p>

<h4 id="the-if-conditional">The “if” conditional</h4>

<p>In most languages, there’s a statement called <strong>if</strong>. Most of the time, <strong>if</strong> is written like:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">if</span><span class="pun">(&lt;</span><span class="pln">some</span><span class="pun">-</span><span class="pln">condition</span><span class="pun">&gt;)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">//Do something</span><span class="pln">
</span><span class="pun">}</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="com">//Do something else</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>It is important to understand that in Scala, <code>if</code> is an expression. Expressions are like functions - commands that returns something. So, we could say that an “if” statement is an special kind of function that maps a <code>Boolean</code> to an arbitrary type. The full “if” definition is the following:</p>

<p><svg class="railroad-diagram" width="1241" height="242" viewBox="0 0 1241 242"><g transform="translate(.5 .5)"><path d="M 20 21 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path><path d="M40 31h10"></path><g><path d="M50 31h0"></path><path d="M86 31h0"></path><rect x="50" y="20" width="36" height="22" rx="10" ry="10"></rect><text x="68" y="35">if</text></g><path d="M86 31h10"></path><path d="M96 31h10"></path><g><path d="M106 31h0"></path><path d="M134 31h0"></path><rect x="106" y="20" width="28" height="22" rx="10" ry="10"></rect><text x="120" y="35">(</text></g><path d="M134 31h10"></path><path d="M144 31h10"></path><g><path d="M154 31h0"></path><path d="M262 31h0"></path><rect x="154" y="20" width="108" height="22"></rect><text x="208" y="35">&lt;condition&gt;</text></g><path d="M262 31h10"></path><path d="M272 31h10"></path><g><path d="M282 31h0"></path><path d="M310 31h0"></path><rect x="282" y="20" width="28" height="22" rx="10" ry="10"></rect><text x="296" y="35">)</text></g><path d="M310 31h10"></path><g><path d="M320 31h0"></path><path d="M616 31h0"></path><path d="M320 31h20"></path><g><path d="M340 31h0"></path><path d="M596 31h0"></path><path d="M340 31h10"></path><g><path d="M350 31h0"></path><path d="M378 31h0"></path><rect x="350" y="20" width="28" height="22" rx="10" ry="10"></rect><text x="364" y="35">{</text></g><path d="M378 31h10"></path><path d="M388 31h10"></path><g><path d="M398 31h0"></path><path d="M538 31h0"></path><rect x="398" y="20" width="140" height="22"></rect><text x="468" y="35">&lt;block-if-true&gt;</text></g><path d="M538 31h10"></path><path d="M548 31h10"></path><g><path d="M558 31h0"></path><path d="M586 31h0"></path><rect x="558" y="20" width="28" height="22" rx="10" ry="10"></rect><text x="572" y="35">}</text></g><path d="M586 31h10"></path></g><path d="M596 31h20"></path><path d="M320 31a10 10 0 0 1 10 10v10a10 10 0 0 0 10 10"></path><g><path d="M340 61h38"></path><path d="M558 61h38"></path><rect x="378" y="50" width="180" height="22"></rect><text x="468" y="65">&lt;expression-if-true&gt;</text></g><path d="M596 61a10 10 0 0 0 10 -10v-10a10 10 0 0 1 10 -10"></path></g><g><path d="M616 31h20a10 10 0 0 1 10 10v60a10 10 0 0 1 -10 10h-616a10 10 0 0 0 -10 10v31a10 10 0 0 0 10 10"></path></g><g><path d="M20 162h0"></path><path d="M604 162h0"></path><path d="M20 162h20"></path><g><path d="M40 162h544"></path></g><path d="M584 162h20"></path><path d="M20 162a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><g><path d="M40 182h0"></path><path d="M584 182h0"></path><path d="M40 182h10"></path><g><path d="M50 182h0"></path><path d="M102 182h0"></path><rect x="50" y="171" width="52" height="22" rx="10" ry="10"></rect><text x="76" y="186">else</text></g><path d="M102 182h10"></path><g><path d="M112 182h0"></path><path d="M376 182h0"></path><path d="M112 182h10"></path><g><path d="M122 182h0"></path><path d="M150 182h0"></path><rect x="122" y="171" width="28" height="22" rx="10" ry="10"></rect><text x="136" y="186">{</text></g><path d="M150 182h10"></path><path d="M160 182h10"></path><g><path d="M170 182h0"></path><path d="M318 182h0"></path><rect x="170" y="171" width="148" height="22"></rect><text x="244" y="186">&lt;block-if-false&gt;</text></g><path d="M318 182h10"></path><path d="M328 182h10"></path><g><path d="M338 182h0"></path><path d="M366 182h0"></path><rect x="338" y="171" width="28" height="22" rx="10" ry="10"></rect><text x="352" y="186">}</text></g><path d="M366 182h10"></path></g><path d="M376 182h10"></path><g><path d="M386 182h0"></path><path d="M574 182h0"></path><rect x="386" y="171" width="188" height="22"></rect><text x="480" y="186">&lt;expression-if-false&gt;</text></g><path d="M574 182h10"></path></g><path d="M584 182a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path></g><path d="M 604 162 h 20 m -10 -10 v 20 m 10 -20 v 20"></path></g></svg></p>

<ul>
<li><strong>condition</strong> is an expression that returns a <code>Boolean</code>. Can be any function that returns boolean, or some comparission like <code>a == 10</code>, <code>b != 20</code>, etc.</li>
<li><strong>block-if-true</strong> is a block to run if the condition is <code>true</code>. Like said before, we’ll talk more about blocks of code</li>
<li><strong>expression-if-true</strong> is an expression to be evaluated if the condition is <code>true</code>. It is important to say that <strong>expression-if-true</strong> is a <strong>single</strong> expression, not a block of expressions</li>
<li><strong>block-if-false</strong> is a block to run if the condition is <code>false</code>.</li>
<li><strong>expression-if-false</strong> is a single expression to run if the condition is <code>false</code>.</li>
</ul>

<p>It is important to say that an <code>if</code> without an <code>else</code> can be considered a statement, and not a expression - for instance, if the <strong>condition</strong> is <code>false</code>, and we have no <code>else</code> clause, Scala does not know what to return, and will return <code>Unit</code> instead.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// Let's implement the discontinuous function that we have seen before</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> discontinuous</span><span class="pun">(</span><span class="pln">x</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">x </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">/</span><span class="pln"> x
discontinuous</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="com">// Will return 0</span><span class="pln">
discontinuous</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="com">// Will return 0.5</span><span class="pln">
discontinuous</span><span class="pun">(</span><span class="lit">0.002</span><span class="pun">)</span><span class="pln"> </span><span class="com">// Will return 500.0</span></code></pre>

<h3 id="recursive-functions">Recursive functions</h3>

<p>Recursive functions are functions that need to call itself. The problem with recursive functions is that they can recurse itself to infinity, for instance, with the case:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> recursive</span><span class="pun">(</span><span class="pln">n</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">+</span><span class="pln"> recursive</span><span class="pun">(</span><span class="pln">n </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">

</span><span class="com">// Applying:</span><span class="pln">
recursive</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln">
</span><span class="com">// Expands to:</span><span class="pln">
</span><span class="lit">3</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> recursive</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span><span class="pln">
</span><span class="com">// Expands to:</span><span class="pln">
</span><span class="lit">3</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> recursive</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="com">// Expands to:</span><span class="pln">
</span><span class="lit">3</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> recursive</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln">
</span><span class="com">// Expands to:</span><span class="pln">
</span><span class="lit">3</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> recursive</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">)</span></code></pre>

<p>and so on, and the evaluation never ends. So, to be able to proper write recursive functions, we <strong>need</strong> to have a “stop condition”: for instance, let’s take the “factorial” example, but first let’s convert it into a “complete” function: when x is equals <strong>or</strong> below zero, we return <code>1</code>. To implement it, we already have our “stop condition”: if our element is zero or below:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// When declaring recursive functions, the return type of the</span><span class="pln">
</span><span class="com">// function is ALWAYS needed.</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">x</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">x </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span></code></pre>

<p>Let’s try to apply it to <code>3</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="lit">3</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="com">// We know that 3 is greater than 0, so we can ignore the first part:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">if</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">))</span><span class="pln">
</span><span class="com">// Again, we can ignore the first part of the if:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="com">// ...</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">if</span><span class="pun">(</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">))</span><span class="pln">
</span><span class="com">// Now, we know that 0 is equals to 0, so we ignore the SECOND part:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">6</span></code></pre>

<p>We can see that in the above code, we have a problem with the return: everytime that we need to return something, we need to “remember” the last return, and calculate factorial again. This is problematic in most programming languages, and there’s a better way to work around this that is called Tail Recursion.</p>

<h3 id="tail-recursive-function">Tail recursive function</h3>

<p>We say that a function is tail-recursive if, when recursing (in other words, when it calls itself) the function <strong>only</strong> calls itself, and don’t do anything else before or after it calls itself: arithmetic expression, no concatenation, nothing. Let’s see how to transform our <code>factorial</code> into a tail-recursive version.</p>

<p>First of all, we need to accumulate the results into an accumulator. In this case, we’ll not multiply the number by the factorial of the <code>number - 1</code>, we’ll pass this multiplication to the recursion. We’ll create a parameter, named <code>acc</code>, that will accumulate the result of the multiplication. We’ll give it a default value too - in this case, <code>1</code> - so that we don’t need to call <code>factorial</code> with two parameters.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">x</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> acc</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
  </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">x </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> acc </span><span class="kwd">else</span><span class="pln"> factorial</span><span class="pun">(</span><span class="pln">x </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> x </span><span class="pun">*</span><span class="pln"> acc</span><span class="pun">)</span><span class="pln">

</span><span class="com">// Let's apply it to three, again:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span><span class="pln">
</span><span class="com">// It will be expanded to:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="lit">3</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">1</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
</span><span class="com">// As always, we'll evaluate the "if", and discard the "true" part:</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln">

</span><span class="com">// We don't have to "remember" anything - so, our call to</span><span class="pln">
</span><span class="com">// factorial(3, 1) can be rewritten as factorial(2, 3):</span><span class="pln">
</span><span class="com">// Please notice that the first part of the "if" returns the acc </span><span class="pln">
</span><span class="com">// parameter. So, in this case we'll return 3.</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">3</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="lit">6</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
factorial</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="lit">6</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">6</span></code></pre>

<p>This code will work <strong>much</strong> better, for the programming language, than the first version - the reason is that in this code, we don’t need to remember states between each recursive call, so we’ll use less memory.</p>

<h3 id="procedures">Procedures</h3>

<p>In Scala, procedures are defined in the same way as functions, but we can ommit the return type of the function and the return type of the function and the <code>=</code> (because procedures don’t return anything). But, we <strong>must</strong> include the <code>{</code> and <code>}</code> on the function.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> printNumber</span><span class="pun">(</span><span class="pln">number</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  println</span><span class="pun">(</span><span class="str">"The number is "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> number</span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Programming with procedures is the <em>standard way</em> on most object-oriented programming languages, but for now we’ll skip it - there are better and less error-prone ways of programming than using procedures. We also introduced <code>String</code>s: a <code>String</code> is simply a text, delimited by <code>"</code>. We’ll see later how to work with <code>String</code>s.</p>

<blockquote>
  <p><strong>Notice</strong></p>
  
  <p>We introduced a <em>procedure</em> here called <code>println</code>. It simply prints the text on the screen, followed by a new line, and returns nothing. </p>
</blockquote>

<h3 id="blocks-of-code">Blocks of code</h3>

<p>When writing functions or <code>if</code> expressions, sometimes it would be easier if we write then in multiple lines. For instance, imagine we need to do some simple arithmetic operations before doing our real code. To do a block of code, we start with a <code>{</code> and end with <code>}</code>. The last expression in the block will be the return of it. So, let’s use our <code>sumOfSquares</code> example code, and rewrite it as a block:</p>

<pre class="prettyprint prettyprinted"><code><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  val squared1 </span><span class="pun">=</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">)</span><span class="pln">
  val squared2 </span><span class="pun">=</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">)</span><span class="pln">
  sum</span><span class="pun">(</span><span class="pln">squared1</span><span class="pun">,</span><span class="pln"> squared2</span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Here, in this context, <code>val</code> just associates a new name to a precomputed result. For instance, I’m squaring the first number <code>n1</code> and associating the result to the identifier <code>squared1</code>. After that, I’m squaring the second number, and associating the result to the identifier <code>squared2</code>. These steps are important in some programs because otherwise, you could end calling <code>square</code> multiple times on the same value, wasting computation time. </p>

<p>One more thing to notice is that there is nothing avoiding you to declare functions <em>inside</em> other functions. So, for instance:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n1 </span><span class="pun">+</span><span class="pln"> n2
  </span><span class="kwd">def</span><span class="pln"> s</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n1 </span><span class="pun">*</span><span class="pln"> n1
  sum</span><span class="pun">(</span><span class="pln">s</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">),</span><span class="pln"> s</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>The difference is that, right now, <code>sum</code> <code>s</code> are declares <strong>inside</strong> the <code>sumOfSquares</code> function. This means that they’re <strong>not</strong> accessible outside the <code>sumOfSquares</code> function, and trying to access it outside would give us an error. </p>

<h1 id="types">Types</h1>

<p>So far, we’ve seen a bunch of types: <code>Int</code> are for integers, <code>Double</code> are for decimals, <code>Boolean</code> are for <code>true</code> and <code>false</code> and, <code>Unit</code> are for procedures - code that doesn’t return anything. We saw that an <code>if</code> without an <code>else</code> clause will behave like a <code>Unit</code>, but we didn’t see how is the relation of each of these types. So, what exactly is a type?</p>

<h2 id="type-hierarchy">Type Hierarchy</h2>

<p><img src="https://docs.google.com/drawings/d/1pFtHQMkK3L7Wx32-WI8l_MFSg0NXPafs5fprIpDHbAA/pub?w=882&amp;h=380"></p>

<p>In Scala, types have an hierarchical structure. The top of the hierarchy is <code>Any</code>, that literally defines any value. Below that, we have <code>AnyVal</code> and <code>AnyRef</code>. <code>AnyVal</code> is the father of all primitive types, and <code>Unit</code> (which is a type to define when a function doesn’t return anything). <code>AnyRef</code> is a supertype of all other types, for instance <code>String</code> (a text) or any type that you’ll define later.</p>

<p>In general, when a type is a child of another, we say that it is a <strong>subtype</strong>. When a type is the father of another, we say it is a <strong>supertype</strong>. So, <code>Double</code> is a <em>subtype</em> of <code>AnyVal</code>, and <code>AnyRef</code> is a <em>supertype</em> of <code>Object</code>.</p>

<p>In Scala, you can define types and you can rename types. Sometimes, renaming a type means you’ll add more meaning to what you’re writing (we’ll see that later), sometimes it just means it is more clear to write the renamed type (and sometimes you’ll write less). If you define another type (for instance, defining a class or a object-we’ll see more about this later), implicitly this new type will be a child of <code>Object</code>.</p>

<h3 id="primitive-types">Primitive types</h3>

<p>Note: you can skip this session if you’re not confident, but <em>please</em> be sure to come back later</p>

<p>For a computer to work, it needs to send commands to the processor. The processor has a way to sum, multiply, subtract and do other arithmetic operations <strong>really</strong> fast. There is another, slower way to process arithmetic data that relies on a higher level of abstraction and don’t depend on primitive types. But, if there is a faster way to process arithmetic data, why use a slower one? The answer is how the processor process and represents primitive data.</p>

<p>To represent an Integer, most programming languages uses the size of a “Word”. In a 64-bit system, the word is 64 bits. On Scala, to be able to be compatible with any system, all integers are 32-bits<a href="#fn:bit" id="fnref:bit" title="See footnote" class="footnote">4</a>-this means we can, at least in theory, represent 2<sup>32</sup> different numbers.</p>

<p>But in scala, an <code>Int</code> is a <strong>signed</strong> integer - in other words, it needs to be able to represent negative numbers. So, computer uses a way do identify negative numbers - it uses the <em>most significant bit</em> (the bit most on the left) to say if a number is negative - <code>0</code> represents a positive number, <code>1</code> a negative one. Let’s simulate this with the following table: suppose our <code>Int</code>s are not 32, but only 3 bits:</p>

<pre class="prettyprint prettyprinted"><code><span class="lit">000</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
</span><span class="lit">001</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="lit">010</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pln">
</span><span class="lit">011</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">3</span><span class="pln">
</span><span class="lit">100</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">4</span><span class="pln">
</span><span class="lit">101</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">3</span><span class="pln">
</span><span class="lit">110</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">2</span><span class="pln">
</span><span class="lit">111</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span></code></pre>

<p>So, let’s say we want to pick the successor of a number: if we look at the table, the successor of <code>-4</code> is <code>-3</code>, of <code>-3</code> is <code>-1</code>, and of <code>-1</code>… well, it will be, in bit format, <code>1000</code>, but this would not fit in our <em>3 bit schema</em>, so we simply discard the most significant bit (in this case, the <code>1</code>) and stay with the rest - <code>000</code> - which will give us the correct answer, in this case: the successor of <code>-1</code> is <code>0</code>.</p>

<p>But, we have a problem here.</p>

<p>If we want the successor of <code>3</code>, being <code>3</code> the greatest integer we can represent, we’ll get the wrong answer: <code>-4</code>. This is called <strong>overflow</strong>, and it is a real problem in programming: To test this in Scala, you can try the following code, below:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="lit">2147483647</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="com">// Result: -2147483648</span></code></pre>

<p>So, if you want larger numbers, you can use <code>Long</code> to represent you numbers. To write a <code>Long</code> value in a simple way, you can postfix the number with <code>l</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="lit">2147483647l</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="com">// Result: 2147483648</span></code></pre>

<p>But <code>Long</code>s are only 64-bit integers: they have a higher limit, but still a limit: we can represent numbers till <code>9223372036854775807</code>, after that we’ll have a overflow again:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">scala</span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">9223372036854775807l</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="com">// Result: -9223372036854775808</span></code></pre>

<p>In these cases, we can use the slower way: BigInt. BigInt does not uses the processor directly, so it is <strong>much</strong> slower. But, at least in theory, we have no limit (only your computer’s memory) to which numbers we can represent:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="typ">BigInt</span><span class="pun">(</span><span class="str">"9223372036854775807"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
</span><span class="com">// Result: 9223372036854775808 (it is a BigInt too)</span><span class="pln">
</span><span class="typ">BigInt</span><span class="pun">(</span><span class="str">"9223372036854775807"</span><span class="pun">).</span><span class="pln">pow</span><span class="pun">(</span><span class="lit">20</span><span class="pun">)</span><span class="pln">
</span><span class="com">// Result: 19851555241898344153130788677769001983160921861226045243324013058499644278985263829655458477500554934148319186908254029753701126211729124925712332077145392772214865805846210362859747023907163434176886296071735509937063967304415184441745878591613191784199114531387951675074220397532740510211790749968004592396387387319085094672935864701114816359825685092500704674453832649932800001</span></code></pre>

<p>It is important to remember: if you <strong>must</strong> be precise on your calculations, you’ll have to use <code>BigInt</code> and <code>BigDecimal</code> to do your math. Otherwise, you can rely on <code>Int</code>, <code>Double</code>, <code>Long</code>, because things will work properly most of the time.</p>

<h3 id="implicit-conversions">Implicit conversions</h3>

<p>Scala can implicitly convert some types that are not really related - for example, both <code>Int</code> and <code>Double</code> descend from <code>AnyVal</code>, but somehow, in our tests we could convert one to another - this is because, implicitly, there’s a way to convert one into other. The rules are more complex than that, but for now let’s imagine that <code>Double</code> behaves like it is a child of <code>Int</code>: where we expect an <code>Int</code>, we could pass a <code>Double</code>, but when we expect a <code>Double</code> we <strong>cannot</strong> pass an <code>Int</code></p>

<h3 id="type-inflection">Type inflection</h3>

<p>Now that we’ve seen how types are related in an hierarquical fashion, we can begin to work on <em>type inflection</em>. Older languages like Java and C++ had the need of declare the type of everything, even when we could easily infer the type. For instance, suppose we’re using the <code>square</code> method, we defined on the first chapters. In that case, we had an <code>Int</code> and we returned it multiplied by itself. Scala <strong>knows</strong> that an <code>Int</code> multiplied by another <code>Int</code> could only be an <code>Int</code> itself. So, why should we need to declare the type? Scala can <em>infer</em> the type from that code easily. But, sometimes, things are not so easy. Let’s consider the following code:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> salary</span><span class="pun">(</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">value </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">100</span><span class="pun">)</span><span class="pln"> value </span><span class="pun">+</span><span class="pln"> </span><span class="lit">50</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> value </span><span class="pun">*</span><span class="pln"> </span><span class="lit">1.2</span></code></pre>

<p>What’s the inflected type on this method? Let’s begin by seeing what we’re doing:</p>

<ol>
<li>First, we’re defining a function that expects an <code>Int</code></li>
<li>Second we’re asking if that value is less than <code>100</code>. It this is true, we’ll add <code>50</code>, and result in an <code>Int</code></li>
<li>Otherwise, we’ll multiply the value to <code>1.2</code> (the equivalent of adding a bunus of 20%), resulting in a <code>Double</code></li>
</ol>

<p>We have two paths, one in which we can return an <code>Int</code>, and one in which we can return a <code>Double</code>. A <code>Double</code> can represent an <code>Int</code>, but an <code>Int</code> cannot represent a <code>Double</code>, so the return of this function is <code>Double</code>.</p>

<p>Now, let’s look at this code:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> positiveUnit</span><span class="pun">(</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">value </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> value</span></code></pre>

<p>Ok, now this code return an <code>Int</code> if the value is above <code>0</code>. Otherwise… it does nothing. So, what’s the type?</p>

<p>In the chapter about the <code>if</code> statement, we saw that <code>if</code> without <code>else</code> will return <code>Unit</code> if the condition is false. So, what type can be used to identify both <code>Int</code> and <code>Unit</code>? If we see the graph, above, we’ll see that this type would be <code>AnyVal</code> - it is the direct <em>supertype</em> of both.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> isMyName</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">name </span><span class="pun">==</span><span class="pln"> </span><span class="str">"Mauricio"</span><span class="pun">)</span><span class="pln"> name</span></code></pre>

<p>This case is the same as above: if the condition is <code>true</code>, it’ll return a <code>String</code>, otherwise, it’ll return <code>Unit</code>. Let’s go up the hierarchy a little: on top of <code>Unit</code> is <code>AnyVal</code>. But, on top of <code>String</code> is <code>AnyRef</code>. <code>String</code> doesn’t descends from the same tree of <code>Unit</code>, so we’ll need to go up a little more-in this case, the only type that <code>String</code> and <code>Unit</code> are related is <code>Any</code>. So, in this specific case, the function returns the type <code>Any</code>.</p>

<h3 id="functions-as-types">Functions as types</h3>

<p>We saw that functions receive parameters (each with its own type) and returns something (that, too, has a type). But how do we represent it?</p>

<p>In Scala, functions <strong>are</strong> types to. So, let’s use the examples of the previous section: we had, for instance, the function <strong>salary</strong>. That function expected an <code>Int</code> and returned a <code>Double</code>. In Scala, we say that the <strong>function</strong> had the type <code>Int =&gt; Double</code>. This kind of type can be read like <strong>something that takes an <code>Int</code> and returns a <code>Double</code></strong>. The same is true for our other functions too: <code>isMyName</code> is of type <code>String =&gt; Any</code>.</p>

<p>But how can we use it?</p>

<p>Let’s return to our code <code>sumOfSquares</code> (for convenience, I’ll annotate the types, and I’ll put a comment too before each function defining which type the <em>function</em> itself is):</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// Int =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">*</span><span class="pln"> n
</span><span class="com">// (Int, Int) =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n1 </span><span class="pun">+</span><span class="pln"> n2
</span><span class="com">// (Int, Int) =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span></code></pre>

<p>We composed this function using two predefined functions: <code>sum</code> and <code>square</code>. But, can we do better? What if we could create a function that squares the first and the second numbers, then applyed some arbitrary function into it? Turns out we can! If we look at our <code>sum</code> function, we see that it is only a type that takes two <code>Int</code>s and return an <code>Int</code>.  So, let’s change our <code>sumOfSquares</code> function to be more composable</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="com">// Int =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n </span><span class="pun">*</span><span class="pln"> n
</span><span class="com">// (Int, Int) =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sum</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n1 </span><span class="pun">+</span><span class="pln"> n2
</span><span class="com">// (Int, Int, (Int, Int) =&gt; Int) =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> composeSquares</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">function</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
  </span><span class="kwd">function</span><span class="pun">(</span><span class="pln">square</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">),</span><span class="pln"> square</span><span class="pun">(</span><span class="pln">n2</span><span class="pun">))</span><span class="pln">

</span><span class="com">//(Int, Int) =&gt; Int</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> sumOfSquares </span><span class="pun">=</span><span class="pln"> composeSquares</span><span class="pun">(</span><span class="pln">_</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> _</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">)</span></code></pre>

<p>A lot of things is going on here, so let’s start slowy: first of all, <code>square</code> and <code>sum</code> are <strong>exactly</strong> the same. We created a new function named <code>composeSquares</code>, that takes two numbers and a function to combine them. The body of <code>composeSquares</code> is mostly the same as <code>sumOfSquares</code> <em>except</em> that we now use a function to compose the result. If we would like to call <code>composeSquares</code> to have exactly the same functionality than <code>sumOfSquares</code>, we could call it like this:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">composeSquares</span><span class="pun">(</span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">,</span><span class="pln"> sum</span><span class="pun">)</span></code></pre>

<p>Because sum is, basically, a function that maps two ints to one. Or, we could do something like:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">def</span><span class="pln"> subtract</span><span class="pun">(</span><span class="pln">n1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> n1 </span><span class="pun">-</span><span class="pln"> n2
composeSquares</span><span class="pun">(</span><span class="lit">3</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> subtract</span><span class="pun">)</span></code></pre>

<p>And our code would run <strong>3<sup>2</sup> - 2<sup>2</sup></strong>. Last of all, we have our new definition of <code>sumOfSquares</code>: it uses the <code>_</code> to say <em>anything</em>. So, in Scala, <code>_</code> is what they call a <strong>wildcard</strong>, that simply matches anything. We need to give it types, because it is a function definition. So, what we’re saying is that <strong><code>sumOfSquares</code> is a function that calls <code>composeSquares</code>. The first parameter can be anything, as long as it is an <code>Int</code>, the second parameter can be anything, as long as it is an <code>Int</code>, but the third parameter must be the function <code>sum</code></strong>. Scala will understand that we need to pass later the first and second parameters, and that the third is already fulfilled, so we don’t need to pass it too. In the end, we’ll have the same result, but using a more generic function.</p>

<hr>

<blockquote>
  <p><strong>Is it better to use the first or the second way?</strong></p>
  
  <p>There is no better or worse in this case. It is just another way to express the same thing. Most of the time, when solving a problem, you’ll need to abstract that problem in a way the machine language can understand. For instance, if you need to add a discount to every person’s salary, maybe having a more generic method can be better-because, in any organization, you can have people with multiple work contracts, so the taxes on each of them are different. It is better to be able to pass a new function that applies the discount and then the taxes, than calculate first the salary already with taxes <em>and then</em> try to figure how much you’ll discount.</p>
  
  <p>There is a great metaphor that says that everything you have in your programming language is like a tool. It is not <em>good</em> or <em>bad</em> in any way, but the more tools you have, the better you’ll be prepared to any kind of problem. </p>
</blockquote>

<h2 id="structures-and-classes">Structures and classes</h2>

<p>So far, we’ve seen programming with primitive types only. But, for any program we’ll make, we’ll have to identify objects in the real world - for instance, how can we identify a person with the current objects we have? Or details of a car? To solve this problem, we need some way to structure complex data from more simple data. In object-oriented programming, the primary structure for that is a <strong>class</strong></p>

<p>A class is nothing more than a collection of attributes and behavior. A class, in fact, is only a structure-a specific collection of attributes is called an <strong>object</strong>. For now, let’s take a specific type of class named <strong>case class</strong>. In Scala, a <em>case class</em> is a kind of structure that already gives you mappings for attributes. For now, let’s work on case classes only with attributes, and begin to add behavior little by little.</p>

<p>Let’s see how could we work with case classes. Imagine we would make a simple supermarket application. To do this, the primary object we would need is a <code>Product</code><a href="#fn:uppercamelcase" id="fnref:uppercamelcase" title="See footnote" class="footnote">5</a>. For now, let’s say that each product has a code, a name and a price</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">def</span><span class="pln"> totalPrice</span><span class="pun">(</span><span class="pln">p1</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> p2</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> p1</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> p2</span><span class="pun">.</span><span class="pln">price</span></code></pre>

<p>This simple code just sums two prices of two products. There are ways of passing multiple products to the method, but we’ll see then later. For now, let’s concentrate on this simple code: how do we create products?</p>

<p>In most programming languages, there is a way to create <strong>objects</strong> from <strong>classes</strong>. Our <code>Product</code> is what we call a <strong>class</strong>, a simple structure that will hold all the product information. In the class, we defined a <code>code</code> and a <code>name</code>, of type <code>String</code>, and a <code>price</code>, of type <code>Double</code>. So, if we need to create an object from that class, we’ll use the keyword <code>new</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">totalPrice</span><span class="pun">(</span><span class="pln">
  </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"10001"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5.75</span><span class="pun">),</span><span class="pln">
  </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"10002"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Chocolate"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">5.0</span><span class="pun">)</span><span class="pln">
</span><span class="pun">)</span></code></pre>

<p>We call this process of creating objects from classes <strong>instantiation</strong>. We <em>instantiate</em> an object from a class using the keyword <code>new</code>. It’s syntax is quite simple: <code>new &lt;class-name&gt;(&lt;parameters&gt;)</code>, like in our case, <code>new Product("10001", "Milk", 5.75)</code></p>

<p>Ok, now we have two products, and we’re passing them to the <code>totalPrice</code> method. But what means the <code>p1.price</code>, that we saw on the <code>totalPrice</code> function?</p>

<h3 id="methods-and-attributes">Methods and attributes</h3>

<p>Let’s look at the <code>.</code>: what it means? Mostly, it means <strong>in this object, run this code</strong>. In the above case, it means <strong>from the object p1, runs the code price</strong>, and, the code <strong>price</strong> is just a code that returns a single value-the price we’ve put on the product. The first product, for instance, could be translated to a single object just by saying:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">object</span><span class="pln"> p1 </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> code </span><span class="pun">=</span><span class="pln"> </span><span class="str">"10001"</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> price </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5.75</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>but, declaring like that, we would miss the information that p1 is, in fact, a <code>Product</code>. We’ll see more about <code>object</code>s later. For now, let’s simply say that a <code>.</code> means that I want to run some code that belongs to a object.  We saw functions, but when the thing we want to run is an attribute - like, it is just an information inside a class, there’s no need to any computation, we can use the keyword <code>val</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">object</span><span class="pln"> p1 </span><span class="pun">{</span><span class="pln">
  val code </span><span class="pun">=</span><span class="pln"> </span><span class="str">"10001"</span><span class="pln">
  val name </span><span class="pun">=</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pln">
  val price </span><span class="pun">=</span><span class="pln"> </span><span class="lit">5.75</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p><code>val</code> is simply a way to store some value in a identifier. Similar with <code>def</code>, it can run a block, but will only run once. If we declare a <code>val</code> like we’ve declared on the object example, above, all of the <code>val</code> code will run exactly the moment we refer to <code>p1</code> the first time. If we declare a val inside a class, it’ll be run when we run the code for the attributes the moment we create an object:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">(</span><span class="pln">givenName</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> surname</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  val fullName </span><span class="pun">=</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    println</span><span class="pun">(</span><span class="str">"Ran the code!"</span><span class="pun">)</span><span class="pln">
    givenName </span><span class="pun">+</span><span class="pln"> </span><span class="str">" "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> surname
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">(</span><span class="str">"Mauricio"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Szabo"</span><span class="pun">)</span><span class="pln"> </span><span class="com">// Here, we'll print 'Ran the code!'</span></code></pre>

<p>Code within <code>val</code> is called an <strong>attribute</strong>. Code within <code>def</code> are called <strong>methods</strong>. We can say that <strong>methods</strong> are procedures and functions, when defined inside a class. And, we can say that an <strong>attribute</strong> is like a method that is computed only once, and always give us the same answer (although this is not exactly true-we can have <em>mutable</em> attributes, but we’ll see then later).</p>

<h4 id="functional-way-of-calling-methods">Functional way of calling methods</h4>

<p>Scala is what we call a multi-paradigm programming language: it supports the object-oriented paradigm (the one that uses objects as data structures) and supports functional programmin (the one that values immutability over mutability, and uses functions to compose behavior). So, Scala supports both ways of calling methods: the <em>object-oriented</em> way (that is, the <code>&lt;object&gt;.&lt;method&gt;(&lt;parameters&gt;)</code> way) and the <em>functional way</em> (the <code>&lt;object&gt; &lt;method&gt; (&lt;parameters&gt; way</code>. Let’s see it in more detail how many ways we have of calling methods on objects:</p>

<p><svg class="railroad-diagram" width="649" height="222" viewBox="0 0 649 222"><g transform="translate(.5 .5)"><path d="M 20 41 v 20 m 10 -20 v 20 m -10 -10 h 20.5"></path><path d="M40 51h10"></path><g><path d="M50 51h0"></path><path d="M134 51h0"></path><rect x="50" y="40" width="84" height="22"></rect><text x="92" y="55">&lt;object&gt;</text></g><path d="M134 51h10"></path><g><path d="M144 51h0"></path><path d="M608 51h0"></path><path d="M144 51h20"></path><g><path d="M164 51h0"></path><path d="M588 51h0"></path><path d="M164 51h10"></path><g><path d="M174 51h0"></path><path d="M202 51h0"></path><rect x="174" y="40" width="28" height="22" rx="10" ry="10"></rect><text x="188" y="55">.</text></g><path d="M202 51h10"></path><path d="M212 51h10"></path><g><path d="M222 51h0"></path><path d="M306 51h0"></path><rect x="222" y="40" width="84" height="22"></rect><text x="264" y="55">&lt;method&gt;</text></g><path d="M306 51h10"></path><g><path d="M316 51h0"></path><path d="M588 51h0"></path><path d="M316 51a10 10 0 0 0 10 -10v-9a10 10 0 0 1 10 -10"></path><g><path d="M336 22h232"></path></g><path d="M568 22a10 10 0 0 1 10 10v9a10 10 0 0 0 10 10"></path><path d="M316 51h20"></path><g><path d="M336 51h0"></path><path d="M568 51h0"></path><path d="M336 51h10"></path><g><path d="M346 51h0"></path><path d="M374 51h0"></path><rect x="346" y="40" width="28" height="22" rx="10" ry="10"></rect><text x="360" y="55">(</text></g><path d="M374 51h10"></path><g><path d="M384 51h0"></path><path d="M520 51h0"></path><path d="M384 51a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path><g><path d="M404 31h96"></path></g><path d="M500 31a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><path d="M384 51h20"></path><g><path d="M404 51h0"></path><path d="M500 51h0"></path><path d="M404 51h10"></path><g><path d="M414 51h0"></path><path d="M490 51h0"></path><rect x="414" y="40" width="76" height="22"></rect><text x="452" y="55">&lt;param&gt;</text></g><path d="M490 51h10"></path><path d="M414 51a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path><g><path d="M414 81h24"></path><path d="M466 81h24"></path><rect x="438" y="70" width="28" height="22" rx="10" ry="10"></rect><text x="452" y="85">,</text></g><path d="M490 81a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path></g><path d="M500 51h20"></path></g><path d="M520 51h10"></path><g><path d="M530 51h0"></path><path d="M558 51h0"></path><rect x="530" y="40" width="28" height="22" rx="10" ry="10"></rect><text x="544" y="55">)</text></g><path d="M558 51h10"></path></g><path d="M568 51h20"></path></g></g><path d="M588 51h20"></path><path d="M144 51a10 10 0 0 1 10 10v60a10 10 0 0 0 10 10"></path><g><path d="M164 131h0"></path><path d="M588 131h0"></path><path d="M164 131h10"></path><g><path d="M174 131h0"></path><path d="M202 131h0"></path><rect x="174" y="120" width="28" height="22" rx="10" ry="10"></rect><text x="188" y="135"> </text></g><path d="M202 131h10"></path><path d="M212 131h10"></path><g><path d="M222 131h0"></path><path d="M306 131h0"></path><rect x="222" y="120" width="84" height="22"></rect><text x="264" y="135">&lt;method&gt;</text></g><path d="M306 131h10"></path><g><path d="M316 131h0"></path><path d="M588 131h0"></path><path d="M316 131a10 10 0 0 0 10 -10v-9a10 10 0 0 1 10 -10"></path><g><path d="M336 102h232"></path></g><path d="M568 102a10 10 0 0 1 10 10v9a10 10 0 0 0 10 10"></path><path d="M316 131h20"></path><g><path d="M336 131h0"></path><path d="M568 131h0"></path><path d="M336 131h10"></path><g><path d="M346 131h0"></path><path d="M374 131h0"></path><rect x="346" y="120" width="28" height="22" rx="10" ry="10"></rect><text x="360" y="135">(</text></g><path d="M374 131h10"></path><g><path d="M384 131h0"></path><path d="M520 131h0"></path><path d="M384 131a10 10 0 0 0 10 -10v0a10 10 0 0 1 10 -10"></path><g><path d="M404 111h96"></path></g><path d="M500 111a10 10 0 0 1 10 10v0a10 10 0 0 0 10 10"></path><path d="M384 131h20"></path><g><path d="M404 131h0"></path><path d="M500 131h0"></path><path d="M404 131h10"></path><g><path d="M414 131h0"></path><path d="M490 131h0"></path><rect x="414" y="120" width="76" height="22"></rect><text x="452" y="135">&lt;param&gt;</text></g><path d="M490 131h10"></path><path d="M414 131a10 10 0 0 0 -10 10v10a10 10 0 0 0 10 10"></path><g><path d="M414 161h24"></path><path d="M466 161h24"></path><rect x="438" y="150" width="28" height="22" rx="10" ry="10"></rect><text x="452" y="165">,</text></g><path d="M490 161a10 10 0 0 0 10 -10v-10a10 10 0 0 0 -10 -10"></path></g><path d="M500 131h20"></path></g><path d="M520 131h10"></path><g><path d="M530 131h0"></path><path d="M558 131h0"></path><rect x="530" y="120" width="28" height="22" rx="10" ry="10"></rect><text x="544" y="135">)</text></g><path d="M558 131h10"></path></g><path d="M568 131h20"></path><path d="M316 131a10 10 0 0 1 10 10v40a10 10 0 0 0 10 10"></path><g><path d="M336 191h78"></path><path d="M490 191h78"></path><rect x="414" y="180" width="76" height="22"></rect><text x="452" y="195">&lt;param&gt;</text></g><path d="M568 191a10 10 0 0 0 10 -10v-40a10 10 0 0 1 10 -10"></path></g></g><path d="M588 131a10 10 0 0 0 10 -10v-60a10 10 0 0 1 10 -10"></path></g><path d="M 608 51 h 20 m -10 -10 v 20 m 10 -20 v 20"></path></g></svg></p>

<p>Now <strong>that</strong> looks complicated… but is not so much when we dive it in detail. Let’s look at the two ways to see it: on the “upper branch” we have the object-oriented way of calling a method: first we begin with an object. To be more didatic, let’s create an object with the three kinds of calls on this diagram:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> inverse</span><span class="pun">():</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(-</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> multiply</span><span class="pun">(</span><span class="pln">other</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">value </span><span class="pun">*</span><span class="pln"> other</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> sumAndMultiply</span><span class="pun">(</span><span class="pln">sum</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">,</span><span class="pln"> mult</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">
    </span><span class="pun">(</span><span class="pln">value </span><span class="pun">+</span><span class="pln"> sum</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> mult</span><span class="pun">.</span><span class="pln">value </span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

val one </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
val two </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span><span class="pln">
val three </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span></code></pre>

<p>For our first test, we’ll use <code>inverse</code>. Please notice that I used <code>()</code> on the end of method definition: because Scala does differentiate between methods that receive no parameters that are declared with parenthesis of the one that are declared without. Methods declared without parenthesis can <strong>only</strong> be called without parenthesis. Methods declared with can be called with or without it. Knowing this, let’s look at the upper branch: it says we can call a method using a <code>.</code>, the method name, and that ends it. So, we can call <code>one.inverse</code>, and <code>one.value</code>, because we expect no parameters. Following still the upper branch, it says we can call this method too using <code>one.inverse()</code>. <code>one.value()</code> doesn’t work, because it is declared without parenthesis (scala understands that methods without parenthesis are meant to be <em>attributes</em>, and in most programming languages, you cannot call an attributes with parenthesis). If we still stay on the upper branch, we can see that, after the parenthesis, we can pass parameters, separated by <code>,</code>. So, we can call <code>two.multiply(three)</code>, and <code>two.sumAndMultiply(one, three)</code>. These are valid calls for the object-oriented way. Please notice that you <strong>cannot</strong> omit the parenthesis in any way.</p>

<p>Now for the functional call (the bottom branch): we write the object name, a space, and the method name. Parenthesis are optional <strong>only</strong> for methods that expects less than two parameters (in other words, one or zero). So, let’s see how each of these methods would be written in a functional way: first, <code>inverse</code> could be written as <code>one inverse</code> or <code>one inverse ()</code>. <code>value</code>, on the other hand, suffers the same fate of the object-oriented way: it can only be written as <code>one value</code>. <code>one multipy two</code> or <code>one multiply (two)</code> are both valid ways of calling this method. Finally, we can only have <code>one sumAndMultiply (two, three)</code> as a valid way to call a method with more than one parameter.</p>

<p>The interesting thing of this code is that we can rename the methods to something more meaningful, like:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">value</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> inverse</span><span class="pun">():</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(-</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> unary_</span><span class="pun">-</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> inverse
  </span><span class="kwd">def</span><span class="pln"> </span><span class="pun">*(</span><span class="pln">other</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">value </span><span class="pun">*</span><span class="pln"> other</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> </span><span class="pun">+*(</span><span class="pln">sum</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">,</span><span class="pln"> mult</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Number</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="pln">
    </span><span class="pun">(</span><span class="pln">value </span><span class="pun">+</span><span class="pln"> sum</span><span class="pun">.</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> mult</span><span class="pun">.</span><span class="pln">value </span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

val one </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">1</span><span class="pun">)</span><span class="pln">
val two </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">2</span><span class="pun">)</span><span class="pln">
val three </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Number</span><span class="pun">(</span><span class="lit">3</span><span class="pun">)</span></code></pre>

<p>This way, we can call these methods like <code>-two</code>, <code>two * three</code> and <code>two +* (one, three)</code>.</p>

<blockquote>
  <p><strong>What about 1 + 2?</strong></p>
  
  <p>Ok, we saw this new way of calling methods. So, this means that 1 + 2 is, in fact, <code>(1).+(2)</code>? The answer is, simply, yes. Basically, all arithmetic operations, even on primitive numbers, are methods on these classes. It’s a new way to look at objects.</p>
</blockquote>

<h3 id="constructors">Constructors</h3>

<p>On most of object oriented programming, to create a class we need to pass some parameters. In our <code>Product</code> example, we had a constructor which received 3 parameters: <code>code</code>, <code>name</code> and <code>price</code>. By default, a constructor does nothing; is up the the programmer to decide what the constructor will do. In the <code>Product</code> example, the constructor bound three identifiers to their following attributes. Most of the time, you’ll want to give some treatment on the constructor parameters, or do some mutability on the object. It is possible to create programs without constructor code (only parameters) like we did on <code>Product</code>. As a simple example, let’s create a <code>class</code> that simply prints it’s parameter when it is instantiated:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Person</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  println</span><span class="pun">(</span><span class="str">"My name is: "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> name</span><span class="pun">)</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>If we construct the class with <code>new Person("Szabo")</code>, it will print on screen <em>My name is: Szabo</em>.</p>

<blockquote>
  <p><strong>A quick reminder:</strong></p>
  
  <p>Remember that every code you write on your constructor will run everytime we instantiate a new class. Sometimes this is desirable, sometimes it is not. Let’s say you have and, in one of its attributes it needs a very big number, let’s say, 2<sup>30</sup>. It is more desirable to put the result there in a <code>val</code> than to compute it everytime we instantiate a new class. Computing everytime will just waste computer processing without a good reason. Remember, computers are fast, but their processing power is not infinite (specially if you plan on using slow languages, or programming for mobile devices like cell phones).</p>
</blockquote>

<h3 id="inheritance">Inheritance</h3>

<p>We saw earlier that types can (and, normaly, will) have father (supertype) and chldren (subtypes). The process of creating a subtype is called <strong>inheritance</strong>, and it is crucial to understand inheritance to understand object oriented programming as it is used in most languages (Javascript, for instance, does not uses <em>inheritance</em> exactly as described here, instead it uses a prototype-based inheritance, but the basics are the same). To make a class inherit from another, we simply use the keyword <code>extends</code> on the class definition:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Father</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Child</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Father</span></code></pre>

<p>When we subclass a class, we get all the methods that were defined on father into the child. We can re-implement these methods, so we can give a more specific behavior (we call this <em>overriding</em>), or we can create new methods. Let’s imagine, right now, that we’ll split our product in more classes: in a general way, a product have a name, but it can not be on sale <em>right now</em>: it could be only a preview, or a free sample, or something like that. But all these things <strong>are</strong> products, only some of then could not be sold. So, let’s adjust these things:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FreeSample</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">
</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Preview</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">

</span><span class="com">// All is good... except this code below doesn't work anymore</span><span class="pln">
val p1 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"10001"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10.5</span><span class="pun">)</span><span class="pln">
p1</span><span class="pun">.</span><span class="pln">price</span></code></pre>

<p>Ok, so now we have some things to look around: first, we’re not using <code>case class</code> anymore. That is because a <code>case class</code> cannot be inherited… and as we don’t know if we’re going to inherit a class in the future, is better to just not risk using a case class. Pity<a href="#fn:caseclassproblem" id="fnref:caseclassproblem" title="See footnote" class="footnote">6</a>. </p>

<p>The second is that when we decide to not use case classes, we lost the benefit of declaring, on the constructor, a code, name and price, and these objects to be available immediately with the dot (<code>.</code>) notation. We can correct these things in two simple ways: first, to rename the param and define a method or a value to the name we want it:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">_name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> name </span><span class="pun">=</span><span class="pln"> _name </span><span class="com">// OR val name = _name</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>But this is just a lot of repeated work. We can, instead, put <code>val</code> before each parameter in a constructor, and then they’ll become public available.</p>

<p>We can, too, define methods on the classes, so they’ll become available on the child classes:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">val name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">val code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> val price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">

  </span><span class="kwd">def</span><span class="pln"> nameForClient </span><span class="pun">=</span><span class="pln"> name </span><span class="pun">+</span><span class="pln"> </span><span class="str">" (R$ "</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> price </span><span class="pun">+</span><span class="pln"> </span><span class="str">")"</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FreeSample</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">,</span><span class="pln"> </span><span class="lit">0.0</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Preview</span><span class="pun">(</span><span class="pln">name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">AbstractProduct</span><span class="pun">(</span><span class="pln">name</span><span class="pun">)</span><span class="pln">

</span><span class="com">// Now this works:</span><span class="pln">
val p1 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"10001"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">10.5</span><span class="pun">)</span><span class="pln">
p1</span><span class="pun">.</span><span class="pln">name </span><span class="com">// returns Milk</span><span class="pln">
p1</span><span class="pun">.</span><span class="pln">nameForClient </span><span class="com">// returns Milk (R$ 10.5)</span><span class="pln">

val p2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FreeSample</span><span class="pun">(</span><span class="str">"10003"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Honey"</span><span class="pun">)</span><span class="pln">
p1</span><span class="pun">.</span><span class="pln">nameForClient </span><span class="com">// returns Honey (R$ 0.0)</span></code></pre>

<p>Obviously, we don’t need to define parameter <code>name</code> for every other child class, because it is already defined in the superclass. The same is true for <code>price</code> on <code>FreeSample</code>. In practice, defining these parameters with <code>val</code> ensures an error because of <strong>overriding</strong>, and we’ll see that later.</p>

<p>One thing to notice is that inheritance is a complicated problem, and most of the time it is used incorrectly: we should use inheritance only when the object we’re writing is a specific version of its supertype. Let’s say we’re writing a code to draw something on the screen: you might be tempted to design your code as the following: a <code>Square</code> is a subclass of <code>Line</code>, that is a subclass of <code>Point</code>. This is problematic in many ways: first of all, what a <em>rounded square</em> is? In this case, the mistake is to think of squares as a specific kind of line, or a line as a “generic square”. This is not the case. A better approach to think it is as a <code>Square</code> and a <code>Line</code> being specific <code>Shape</code>s. In this case, we would have a (very) generic class <code>Shape</code>, and <code>Line</code>, <code>Point</code> and <code>Square</code> as subclasses: specific shapes.</p>

<blockquote>
  <p><strong>Identifying inheritance information</strong></p>
  
  <p>A simple way to think about inheritance is to think what a object <strong>is</strong>. In the above example,  we had <code>Square</code> and <code>Line</code>. A <code>Square</code> is <strong>not</strong> a <code>Line</code>. But, a <code>Line</code> and a <code>Square</code> <strong>are</strong> <code>Shape</code>s, so this kind of inheritance makes sense.</p>
</blockquote>

<h3 id="abstract-classes-and-contracts">Abstract classes and contracts</h3>

<p>A contract, in the wild, is a document that binds a set of rules: everyone must follow that group of rules, or face the consequences. When designing systems, the contract is exactly the same.</p>

<p>In programming we define a contract defining abstract classes. Abstract classes work exactly the same as “concrete” classes except that they have methods that are not implemented, only defined (in other words, they don’t have the <em>body</em> part, and must always annotate the return type). We call these <strong>abstract methods</strong>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> contains</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Boolean</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> totalPrice</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>An abstract class <strong>must</strong> be annotated with the <code>abstract</code> keyword. Ever. This is simple: if we subclass (inherit) an abstract class, we <strong>must</strong> implement all the methods that are declared, but not implemented. So, if we forget to implement a single one, the class is forced to be abstract-so, if we don’t declare it as abstract, in these cases, we get an error. Scala, on the other way, makes it simple to implement the methods with <em>stubs</em> - fragments of code that just don’t do anything, and gives us an error if we try to use then - so we won’t have an abstact method anymore, and we can concentrate on giving the correct behaviour later:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> contains</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Proccut</span><span class="pun">):</span><span class="pln"> </span><span class="typ">Boolean</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> totalPrice</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Nice! Now, we can proceed to create some behavior on this code:</p>

<h4 id="the-shopping-cart">The shopping cart</h4>

<p>Let’s say we’re going to create a shopping cart in code. There are better ways of doing this using lists of products, but we’re not gonna use then <strong>right now</strong>: first, we need to be introduced to generics and lists, and so on. Instead, we’ll use <em>inheritance</em> only. Let’s first define a <em>contract</em>: what a shopping cart needs to do? Even better: what should we <strong>ask</strong> for the shopping cart to give us, so we can continue our work? Well, we need to inform the user the total of his buy. We need to inform how many items he’s buying, we need to add a new item on the shopping cart, remove an item from the shopping cart, and finally, the user needs to <em>know</em> what he’s buying. What about we just print on the screen what he’s buying, one item per line?</p>

<p><strong>NEVER!</strong></p>

<p>Making the shopping cart print itself on the screen is a <strong>very bad</strong> idea. The reason is simple: what a shopping cart needs to <strong>do</strong> is to have rules about the sale. A code that prints one item per line is adding a behavior that it is <strong>not</strong> on the shopping cart responsability: show the user something. We will, instead, make a code to inform the program what we have on cart, and then create a code to show this in a meaningful way.</p>

<p>Now, on to the code. The first thing we’ll going to do is to create a class to define a product. Let’s just use the <code>case class Product</code> we had earlier, for the sake of simplicity. Then, we need to see each case of the shopping cart that we’ll deal with, but first let’s just write the contract we defined earlier:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="com">// For now, let's skip these methods. We'll implement then later,</span><span class="pln">
  </span><span class="com">// when things become clearer</span><span class="pln">
  </span><span class="com">//def add(product: Product): ?</span><span class="pln">
  </span><span class="com">//def remove(product: Product): ?</span><span class="pln">
  </span><span class="com">//def products: ?</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<h4 id="representing-an-empty-shopping-cart">Representing an empty shopping cart</h4>

<p>First of all, how would we represent the first case of our shopping cart, in this case, an empty shopping cart? Well, it is simple, really: <code>total</code> and <code>numberItems</code> is <code>0</code>-there is nothing on the cart!</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Well, that was simple. So, what now? Let’s say we want to add an item into the cart. How would we do? Well, we can not <code>add</code> something to a class named <code>EmptyCart</code> - that would be absurd! An <code>EmptyCart</code> that is not empty? Nonsense. So, we just return a new cart! One that has a product in it! <code>remove</code> is implemented on the same way, we return a new cart <strong>without</strong> the product on it. Let’s update our abstract shopping cart now:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="com">// For now, let's skip this method. We'll implement it later,</span><span class="pln">
  </span><span class="com">// when things become clearer</span><span class="pln">
  </span><span class="com">//def products: ?</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>See something interesting? Althrough the <code>ShoppingCart</code> is an abstract class, we can still return objects of its type. The reason is simple: we’ll return concrete implementations of this abstract class (for example, <code>EmptyCart</code> is one). This is how a contract is done: we say that we’re passing an object that <em>implements</em> these methods, and Scala makes sure that we’ll obey the contract. So, now to the implementation of <code>Empty</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Well, <code>remove</code> was simple: there is nothing on the cart, so we remove nothing. But, <code>add</code> is not possible to implement yet: we have no concrete implementation of <strong>any</strong> cart that has a product on it. So, we could define one! Let’s define a cart where we have a single product on it:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Now, we can add a product into an <code>EmptyCart</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<h4 id="a-single-product-cart">A single product cart</h4>

<p>Now that we’ve defined a single product cart, we need to implement it’s methods. Two of then are quite simple: we just need to return the price of the product for <code>total</code> and as for the number of items, we only have one:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>But there are still problems: could we remove a product? Well, we can, but <strong>only if</strong> the product that we have on cart is the product we’re trying to remove: in this case, the cart becomes <em>empty</em> again. But, if it is not, then the cart remains unchanged. How?</p>

<p>There is a special keyword in Scala named <code>this</code>. <code>this</code> simply returns the class we’re in. So, if inside the <code>SingleProductCart</code> we simply return <code>this</code>, we’re not creating a new class: we’re just refering to itself. We could, for instance, avoid the creation of a new <code>EmptyCart</code> on the <code>remove</code> method of it, and we could avoid the creation of a new <code>SingleProductCart</code> if the product we’re removing is not the same that this cart holds:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>We’ve seen too a good way of using <code>this</code> on the above code: in the <code>remove</code> method, the parameter name is <code>product</code>. But, the product we’re holding (the one that we passed to the constructor) is named <code>product</code> too… To differentiate between then, we’ve used <code>product</code> to refer to the parameter, and <code>this.product</code> to refer the one that we’ve passed on the constructor. In a way, this makes sense: the one we’ve passed to the constructor is now <em>part</em> of the class, so we access it with <code>this.&lt;name&gt;</code></p>

<p>We’re still missing a way to put another product on cart… we could create a class named <code>TwoProductsCart</code>, but this would go on and on… so, what to do?</p>

<h4 id="a-cart-for-more-products">A cart for more products</h4>

<p>Imagine you’re going to travel somewhere for a whole month, and you discover you don’t have a big suitcase! You only have a bunch of very small ones. Well, what you could do is just put things in one, then continue putting things on another… and, when you get to your destination, you unpack the first, then the second, then the third… you get the idea.</p>

<p>What we’ll do with this code is <strong>exactly</strong> the same: we’re going to create a cart that will just hold a single product, but somehow will tell us that there are <strong>more</strong> items, and then we could find these ones!</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Well, now we can updated our <code>SingleProductCart</code> with the new cart</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>But, still, we need to implement the methods of our contract. What’s the <code>total</code> price? This one is simple: we have the <code>total</code> of our previous cart, don’t we? Well, let’s just add the price of the current product into the <code>total</code> of the previous cart! Let’s work the same way on the <code>numberItems</code>:</p>

<p><code>add</code> is simple too: we just add another cart! Let’s see it in action:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Well, <code>remove</code> is missing. How would we remove this product? Well, the first case is kinda simple: if the product we’re trying to remove is the that we have on this cart, we could just return the previous cart, and it’s done. It’s the same as if you organize your travel’s suitcases in a way that every clothes of the same color would stay in a single suitcase. Let’s say we have these suitcases, one in top of the other (this makes things kinda simple). If the one on top is the one that contains only the red clothes, and you’re tired of these old same red clothes, you could just discard it! Easy, and you’ll still all your other clothes.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> cart
    </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>The second case is quite more complicated: if the product we’re trying to remove is <em>not</em> the same we have now, we need to see if it is on the previous carts. If it is, we discard these carts, and reconstruct the list of carts. If it is not, we mantain things are they are. That is the first though that comes in our minds, I think. And it is <strong>wrong</strong>.</p>

<p>It is <strong>not</strong> this cart’s responsability to check if the products on other carts are present or not. It is the <strong>other cart’s</strong> responsability. So, what we could do is simple: to create a new cart that will hold our product, and then the other cart will simply be the cart with the product removed:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> cart 
    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">))</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<h5 id="understading-and-proving"><strong>Understading, and proving</strong></h5>

<p>To understand this kind of code, imagine movies when they show Las Vegas casinos, when people come handcuffed with their suitcases. Let’s imagine the same thing: imagine we have two kinds of suitcases: one of then is the one you and I know, and the other has a un-detachable string that ends in a grip clip or something. The idea is that we <strong>cannot</strong> detach this second suitcase from any other by any means, other than destroying the clip (and invalidating the suitcase on the process). I know it is a bit extreme, but that is how working with immutable objects is.</p>

<p>Now, <code>SingleProductCart</code> and <code>EmptyCart</code> are like the first kind of suitcase: it contains a product inside or it is empty, and that’s it. The second kind of suitcase is like the <code>AdditionalCart</code>. So, imagine we have the following: three suitcases, the first contains red shirts and it is bound to the second, that contains blue shirts. That one is bound to the third, that is a simple suitcase that contains only black pants. Imagine we want to get rid of all red shirts. In this case, we look at the first suitcase, see it contains red shirts, and we destroy that suitcase and pick the next on the list. Now, we have no more red shirts. </p>

<p>Now, suppose we want to get rid of blue shirts. In this case, we look at the first suit, see it does <strong>not</strong> contains blue shirts. Now, we pick up a new suitcase of the same kind, we transfer all the clothes we had on this first suitcase(the red shirts, in this case), and then we destroy this suitcase. Now, we look at the second suitcase. We see it indeed contains blue shirts, then we destroy it, and pick the next on the list. We bind the new first suitcase with this one, and now we have a <strong>new</strong> suitcase with red shirts, bound to one that has only black pants.</p>

<p>At last, we want to get rid of our black pants. We look at the first suit, and it does not contains black pants. We transfer its contents to a new suitcase, destroy it, and look at the next suitcase. We see it not contains black pants, then we transfer the clothes to a new suitcase, and we destroy it too. This <strong>new</strong> suitcase (with blue shirts) is bound to the <strong>previous new</strong> suitcase (the one with red shirts), and we look at the next suitcase. This one indeed contains black pants, and then we empty it, and this (now empty) suitcase is bound to the <strong>previous new</strong> suitcase (the one with blue shirts). Now, we have no more black pants.</p>

<h4 id="removing-unused-code">Removing unused code.</h4>

<p>Our full code is the following:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">SingleProductCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> cart 
    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">))</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>If we look at this code, we can see something strange: there is duplicated code! Look at the implementation of <code>total</code> and <code>numberItems</code> in both <code>AdditionalCart</code> and <code>SingleProductCart</code>. They’re almost the same, except that <code>AdditionalCart</code> sums with the previous cart’s content! What if we remove this more generic cart from the code, will it still work?</p>

<p>Well, a <code>SingleProductCart</code> is nothing more than a <code>AdditionalCart</code> where the previous cart is <code>Empty</code>. Well, we could easily get rid of it in this way: just make <code>EmptyCart</code> return an <code>AdditionalCart</code> with itself as previous, and be done with it.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> cart 
    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">))</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>The usage of this code is kinda simple: we just create a new <code>EmptyCart</code> and add products to it:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="pln">val p1 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"1"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8.0</span><span class="pun">)</span><span class="pln">
val p2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"2"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Chocolate"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4.5</span><span class="pun">)</span><span class="pln">
val p3 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"3"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Rice"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">7.0</span><span class="pun">)</span><span class="pln">
val cart </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln">

val cartWithP1 </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">p1</span><span class="pun">)</span><span class="pln">
cartWithP1</span><span class="pun">.</span><span class="pln">numberItems </span><span class="com">// Returns 1</span><span class="pln">
cartWithP1</span><span class="pun">.</span><span class="pln">total </span><span class="com">// Returns 8.0</span><span class="pln">

val cartWithMore </span><span class="pun">=</span><span class="pln"> cartWithP1</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">p3</span><span class="pun">)</span><span class="pln">
cartWithMore</span><span class="pun">.</span><span class="pln">numberItems </span><span class="com">// Returns 2</span><span class="pln">
cartWithMore</span><span class="pun">.</span><span class="pln">total </span><span class="com">// Returns 15.0</span></code></pre>

<p>What more can we improve? Well, <code>EmptyCart</code> really has no kind of behavior. It is just a collection of methods, it is constructed without parameters, and if we call any of its methods a bunch of times, it’ll <strong>always</strong> behave the same. It just doesn’t need to be a class when we declare new instances, we can declare a single instance of <code>EmptyCart</code> and reuse always.</p>

<p>These kind of classes that have only one instance are called <strong>singletons</strong>. A <em>singleton</em>, in Scala, can be easily declared using the <code>object</code> keyword, in place of <code>class</code> one. As a <em>singleton</em> is only a single object, we cannot create then with <code>new</code>, we just use the name of then and that’s it.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">case</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="pln">code</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> price</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pun">)</span><span class="pln">

</span><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">object</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> product</span><span class="pun">.</span><span class="pln">price </span><span class="pun">+</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">total
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">numberItems </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> 
    </span><span class="kwd">if</span><span class="pun">(</span><span class="pln">product </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="pln">product</span><span class="pun">)</span><span class="pln"> cart 
    </span><span class="kwd">else</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> cart</span><span class="pun">.</span><span class="pln">remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">))</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

val p1 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"1"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Milk"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">8.0</span><span class="pun">)</span><span class="pln">
val p2 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"2"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Chocolate"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">4.5</span><span class="pun">)</span><span class="pln">
val p3 </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">(</span><span class="str">"3"</span><span class="pun">,</span><span class="pln"> </span><span class="str">"Rice"</span><span class="pun">,</span><span class="pln"> </span><span class="lit">7.0</span><span class="pun">)</span><span class="pln">

val cartWithP1 </span><span class="pun">=</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">p1</span><span class="pun">)</span><span class="pln">
cartWithP1</span><span class="pun">.</span><span class="pln">numberItems </span><span class="com">// Returns 1</span><span class="pln">
cartWithP1</span><span class="pun">.</span><span class="pln">total </span><span class="com">// Returns 8.0</span><span class="pln">

val cartWithMore </span><span class="pun">=</span><span class="pln"> cartWithP1</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">p3</span><span class="pun">)</span><span class="pln">
cartWithMore</span><span class="pun">.</span><span class="pln">numberItems </span><span class="com">// Returns 2</span><span class="pln">
cartWithMore</span><span class="pun">.</span><span class="pln">total </span><span class="com">// Returns 15.0</span></code></pre>

<p>Please notice that <em>singletons</em> are <strong>not</strong> classes, nor they are types-they are objects, and <strong>will work</strong> as objects. For instance, in <code>AdditionalCart</code>, we expect in the constructor a parameter of type <code>ShoppingCart</code>. <code>EmptyCart</code> is a <code>ShoppingCart</code> (because it extends <code>EmptyCart</code>), so we can pass it as a parameter to the constructor like this: <code>new AdditionalCart(product, Empty)</code>.</p>

<blockquote>
  <p><strong>Notice</strong></p>
  
  <p>When you use a singleton, in reality you are <strong>always</strong> using the same object. Beware of that. If you declare a <em>mutable singleton</em>, one that changes its internal state in the middle of the program, you can end with a <strong>very difficult</strong> program to understand, and end with <strong>very dificult</strong> bugs to find.</p>
</blockquote>

<p>We’ll implement a way to pick up all our products in a shopping cart in the next chapters. The idea will be, basically, the same thing we did here, but without needing to create additional classes. We created new classes here because we needed to instantiate then. To return all products in the cart, we need to create a kind of iterator: something that returns the products until there are no products left. But first, let’s talk about a new concept:</p>

<h3 id="anonymous-classes">Anonymous classes</h3>

<p>Not all classes need to have names. We can create classes without names, and use then as if they are their superclasses. This is useful if we have abstract classes that we want to instantiate, but don’t want to pass through the process of defining a new class and instantiating then. This is <strong>important</strong>: don’t create anonymous classes for more complex cases-this can lead to code which is difficult to understand. That being said, let’s imagine the following case: an <em>iterator</em>:</p>

<p>Imagine we have structure that concentrates some kind of element, like our <code>ShoppingCart</code>. A possible implementation of an <em>iterator</em> is something that, when we have a new element, return it. If we have no element, we have an undefined behaviour. So, to see if we have new elements, we can use <code>hasNext</code>, that returns if we have, or not, new elements to return.</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ProductIterator</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> hasNext</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Boolean</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>Now, we see that we have to implement these two methods. So, our abstract <code>ShoppingCart</code> is:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> products</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ProductIterator</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<p>If we try to run our code right now, we’ll see that we <strong>need</strong> to implement these methods on <code>EmptyCart</code> and <code>AdditionalCart</code>. This is a something we must <strong>always</strong> be aware of: when we’re defining code that is meant to be inherited, if we add a new abstract method, we will need to add this abstract method to all subclasses, and this can be <strong>really</strong> problematic. But for now, let’s implement it for <code>EmptyCart</code>:</p>

<pre class="prettyprint prettyprinted"><code class="language-scala"><span class="kwd">object</span><span class="pln"> </span><span class="typ">EmptyCart</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> total</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Double</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0.0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> numberItems</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Int</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> add</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AdditionalCart</span><span class="pun">(</span><span class="pln">product</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">)</span><span class="pln">
  </span><span class="kwd">def</span><span class="pln"> remove</span><span class="pun">(</span><span class="pln">product</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pun">):</span><span class="pln"> </span><span class="typ">ShoppingCart</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">this</span><span class="pln">

  </span><span class="kwd">def</span><span class="pln"> products</span><span class="pun">:</span><span class="pln"> </span><span class="typ">ProductIterator</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ProductIterator</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">def</span><span class="pln"> hasNext</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Boolean</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pln">
    </span><span class="kwd">def</span><span class="pln"> </span><span class="kwd">next</span><span class="pun">:</span><span class="pln"> </span><span class="typ">Product</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>

<div class="footnotes"><hr><ol><li id="fn:camelcase">when we write identifiers, we need the camelCase notation. In this notation, every identifier starts with a lower case character, and is preceded by lowercase characters until we hit a space - then, we remove the space and the following word starts with a upper case character. So, for example, if we want an identifier to be named “ammount of money”, in camelCase notation we write it as <code>ammountOfMoney</code>. It is possible to use numbers in camelCase, but not as the first character. So, for instance, <code>sumWith2</code> is a valid identifier, but <code>2ForOne</code> is not. camelCase is a convention used in Scala, Javascript, Java, C# and other languages.  <a href="#fnref:camelcase" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:answer1">The first code doesn’t work because we’re passing a decimal to a function that expects an integer. Scala doesn’t knows what to do with the decimal number - should it round up? Round down? Discard the decimal part altogether? As for the second function, it’ll work because we’re passing an integer to a function that expects a decimal - converting from integer to decimal is a simple matter of adding a decimal part to it. To understand better, try to imagine that if I want a decimal, and passes it the number <code>2</code>, I can convert it to a decimal simply: <code>2.0</code> is a valid decimal. But, if I want an integer, and get a <code>2.4</code>, I don’t have a sane way to automatically convert it to an integer. <a href="#fnref:answer1" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:application">We call “function application” when we have a function defined, and we call it with a number of parameters. It is <strong>very</strong> important to understand that <em>function application</em> and <em>function calling</em> are <strong>exactly</strong> the same thing, but we call it “application” because it is a more mathematical-correct term, and because we’ll see it in action how the computer uses the parameters that we pass to the function to compute, in fact, a result. <a href="#fnref:application" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:bit">Remember, a bit can only store two single values: <code>0</code> and <code>1</code>. So, in this case, <code>1 + 1</code> is <code>10</code>, <code>10 + 1</code> is <code>11</code>, <code>11 + 1</code> is <code>100</code>, and so on. <a href="#fnref:bit" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:uppercamelcase">In most programming languages, when defining a type (creating a new class, for instance), we use CamelCase too, but in this case the first character is in upper case. So, if we need to create a class to represent printers, we could name a class for inkjet printers as <code>InkjetPrinter</code>, for instance. <a href="#fnref:uppercamelcase" title="Return to article" class="reversefootnote">↩</a></li><li id="fn:caseclassproblem">Here we see a <strong>very</strong> interesting thing: sometimes, programming languages’ creators make some decisions that not all people agree. This is normal, and it’s the work of programmers to know, and circunvent, programming languages’ limitations. <a href="#fnref:caseclassproblem" title="Return to article" class="reversefootnote">↩</a></li></ol></div></div></body>
</html>